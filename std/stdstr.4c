// &dest byte len --
pub :memset {
    var int len: {}
    var char value: {}
    var ptr dest: {}
    #macro USE_MEMCPY_MINIMUM { 16 }
    #macro MIN(a,b) { if ((a) (b) <) {a} else {b} }

    var int fill_to: { MIN(len, USE_MEMCPY_MINIMUM) }
    for (var int i: 0, i fill_to <, 1+=i) {
        value (dest i+) !c
    }
    if fill_to len == { return }

    var int filled: USE_MEMCPY_MINIMUM
    while filled len < {
        var int chunk: { MIN(filled, len filled-) }
        dest (dest filled+) chunk memcpy
        chunk +=filled
    }
}

// &str -- len
pub :strlen {
    dup while dup@c { 1+ }
    swap -
}

// &src &dest --
pub :strcpy {
    over strlen 1+ memcpy
}

// &src &dest n --
pub :strncpy {
    var int n: {}
    if over strlen n < { over strlen =n }
    0 over n+ 1+ !c
    n memcpy
}

// &src &dest --
pub :strcat {
    dup strlen+ strcpy
}

// &str1 &str2 -- diff
pub :strcmp {
    while over@c over@c | {
        if over@c over@c - dup {
            rot rot drop drop
            return
        } drop
        1+ swap 1+ swap
    }
    drop drop
    0
}

// &str1 &str2 n -- diff
pub :strncmp {
    var int n: {}
    while (over@c over@c | flag) (n flag) & {
        if over@c over@c - dup {
            rot rot drop drop
            return
        } drop
        1+ swap 1+ swap
        1 -=n
    }
    drop drop
    0
}

// &str char -- [ptr, 0]
pub :strchr {
    while over@c dup {
        if over == {
            drop return
        }
        swap 1+ swap
    } drop
    drop drop 0
}

// &str &substr -- [ptr, 0]
pub :strstr {
    var &char src: {swap}
    var int sub_len: {dup strlen}
    while src@c {
        if src over sub_len strncmp not {
            drop src return
        }
        1 +=src
    }
    drop 0
}