#use "__core/intrinsics.4c"

pub struct int {[8] __inner}
#pub macro INT_MIN {-9223372036854775808}
#pub macro INT_MAX {9223372036854775807}
pub struct ptr {[8] __inner}
pub struct char {[1] __inner}
#pub macro CHAR_MIN {0}
#pub macro CHAR_MAX {255}
pub struct bool {[1] __inner}

#pub macro NULL {0}
#pub macro false {0}
#pub macro true {1}
#pub macro != {== 1 ^}
#pub macro <= {> 1 ^}
#pub macro >= {< 1 ^}
pub :is_success {-1 >}
pub :is_failure {0 <}
pub :flag {if {true} else {false}}
pub :not {if {false} else {true}}

// a -- a a
pub :dup {0 pick}
// a b -- a b a
pub :over {1 pick}
// a b -- b a
pub :swap {1 roll}
// a b c -- b c a
pub :rot {2 roll}
// a b -- b
pub :nip {swap drop}

#pub macro / {divmod drop}
#pub macro % {divmod nip}

#pub macro ! {store}
#pub macro @ {fetch}
#pub macro @++ {dup@ dup 1+ rot!}
#pub macro ++@ {dup@ 1+ dup rot!}
#pub macro @-- {dup@ dup 1- rot!}
#pub macro --@ {dup@ 1- dup rot!}

pub :storec {
    dup fetch 0xff ~ &
    rot 0xff & |
    swap store
}
#pub macro !c {storec}
pub :fetchc {fetch 0xff &}
#pub macro @c {fetchc}
#pub macro @c++ {dup@c dup 1+ rot!c}
#pub macro ++@c {dup@c 1+ dup rot!c}
#pub macro @c-- {dup@c dup 1- rot!c}
#pub macro --@c {dup@c 1- dup rot!c}

#ifdef OS_LINUX {
    #use "__core/linux.4c"
}
#ifdef OS_WINDOWS {
    #use "__core/windows.4c"
}

// &ptr len fd -- [bytes_read, -1]
pub :fread {
    #ifndef OS_WINDOWS { __fread }
    #ifdef OS_WINDOWS {
        $ptr buf: {2 pick}
        $int res: {__fread}
        if res is_failure { res return }

        $int new_i: {0}
        for $int i: {0}, (i res <) (buf i+ @c flag) &, 1 +=i {
            $ptr ch: {buf i+}
            if (ch@c '\r' ==) (ch 1+ @c '\n' ==) & { continue }
            ch@c (buf new_i+)!c
            1 +=new_i
        }
        0 (buf new_i+)!c
        new_i
    }
}

// &ptr len fd -- [bytes_written, -1]
pub :fwrite {
    #ifndef OS_WINDOWS { __fwrite }
    #ifdef OS_WINDOWS {
        $ptr fd: {}
        $int len: {}
        $ptr buf: {}

        $int n_newlines: {0}
        $int i: {0}
        for , (i len <) (buf i+ @c flag) &, 1 +=i {
            if (buf i+ @c) ('\n') == {
                1 +=n_newlines
            }
        }

        i n_newlines+ =len

        $ptr new_buf: { len win_LocalAlloc }
        if new_buf is_failure { 1 exit }

        for $int j: {0} $int new_i: {0}, j i <, 1 +=j 1+=new_i {
            if (buf j+ @c) ('\n') == {
                '\r' (new_buf new_i+)!c
                1+=new_i
            }
            (buf j+ @c) (new_buf new_i+)!c
        }

        new_buf len fd __fwrite
        if new_buf win_LocalFree is_failure { 1 exit }
    }
}

// &buf len -- [bytes_written, -err]
pub :getcwd {
    #ifndef OS_WINDOWS { __getcwd }
    #ifdef OS_WINDOWS {
        $ptr cwd: {over}
        $int res: {__getcwd}
        if res is_success {
            '\\' cwd res+ !c
            0 cwd res+ 1+ !c
            res 1+
        } else {
            res
        }
    }
}

// &buf len -- bytes_read
pub :stdin {STDIN_FD fread}
// &ptr len --
pub :stdout {STDOUT_FD fwrite drop}
// &ptr len --
pub :stderr {STDERR_FD fwrite drop}