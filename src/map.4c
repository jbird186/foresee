#include "std/stdstr.4c"
#include "src/config.4c"

// str_ref -- hash
:hash {
    5381
    while over@c {
        dup 5 << + over@c +
        swap 1+ swap
    }
    nip
    if dup 0 < { -1* }
}

// slot_ptr -- bool
:slot_is_empty { @ not }
// slot_ptr -- bool
:slot_is_used { @ flag }
// idx map_ref slot_size -- slot_ptr
:map_idx { rot* + }

// key map_ref slot_size idx -- key map_ref slot_size idx slot_ptr bool
:_map_slot_skip {
    // -- key map_ref slot_size idx slot_ptr
    over over* 3 pick +
    if dup slot_is_empty {
        false
    } else {
        dup@ 5 pick str_cmp flag
    }
}
// key map_ref slot_size -- slot_ptr
:get_map_slot {
    2 pick hash MAP_SIZE %
    // -- key map_ref slot_size idx slot_ptr
    while _map_slot_skip {
        drop
        1+ MAP_SIZE %
    }
    nip nip nip nip
}
// key map_ref slot_size -- idx
:get_map_idx {
    2 pick hash MAP_SIZE %
    // -- key map_ref slot_size idx slot_ptr
    while _map_slot_skip {
        drop
        1+ MAP_SIZE %
    }
    drop nip nip nip
}
// key map_ref slot_size -- bool
:map_contains {
    get_map_slot slot_is_used
}

// key scope map_ref slot_size idx -- key scope map_ref slot_size idx slot_ptr bool
:_scoped_map_slot_skip {
    // -- key scope map_ref slot_size idx slot_ptr
    over over* 3 pick +
    if dup slot_is_empty {
        false
    } else if dup@ 6 pick str_eq {
        dup->ScopedKey.scope@ 5 pick !=
    } else {
        true
    }
}
// key scope map_ref slot_size -- slot_ptr
:get_scoped_map_slot {
    3 pick hash MAP_SIZE %
    // -- key scope map_ref slot_size idx slot_ptr
    while _scoped_map_slot_skip {
        drop
        1+ MAP_SIZE %
    }
    nip nip nip nip nip
}
// key scope map_ref slot_size -- idx
:get_scoped_map_idx {
    3 pick hash MAP_SIZE %
    // -- key scope map_ref slot_size idx slot_ptr
    while _scoped_map_slot_skip {
        drop
        1+ MAP_SIZE %
    }
    drop nip nip nip nip
}
// key scope map_ref slot_size -- bool
:scoped_map_contains {
    get_scoped_map_slot slot_is_used
}