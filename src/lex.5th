#include "std/stdio.5th"
#include "std/stdchar.5th"
#include "std/stdarr.5th"
#include "std/stdstr.5th"
#include "src/config.5th"
#include "src/token.5th"

// src_ptr --- src_ptr char
:viewc { dup @c }

// src_ptr --- new_src_ptr int
:view_int {
    if viewc '-' == {
        -1 swap 1+
    } else {
        1 swap
    }

    $lex_int_total INT
    viewc '0' - &lex_int_total!
    while viewc {
        1+
        if viewc is_digit {
            viewc '0' -
            &lex_int_total@ 10 * + &lex_int_total!
        } else if viewc '_' != {
            &lex_int_total@
            rot *
            return
        }
    }
    rot *
}

// src_ptr --- src_ptr char
:match_char {
    if viewc '\\' == {
        1+
        // null
        if viewc '0' == { '\0' }
        // newline
        else if viewc 'n' == { '\n' }
        // tab
        else if viewc 't' == { '\t' }
        // vertical tab
        else if viewc 'v' == { '\v' }
        // form feed
        else if viewc 'f' == { '\f' }
        // return
        else if viewc 'r' == { '\r' }
        // single quote
        else if viewc '\'' == { '\'' }
        // double quote
        else if viewc '\"' == { '\"' }
        // backslash
        else if viewc '\\' == { '\\' }
        else {
            "ERROR: Invalid escape character '\\".s viewc.c "'\n".s
            1 exit
        }
    } else { viewc }
}

// src_ptr --- new_src_ptr char
:view_char {
    1+
    match_char
    swap 1+

    if viewc '\'' != {
        "ERROR: Expected endquote after valid character '".s swap .c "'\n".s
        1 exit
    }

    1+ swap
    return
}

// src_ptr --- new_src_ptr ref
:view_str {
    &strs_mem headc swap
    1+
    while viewc '\"' != {
        match_char &strs_mem pushc
        1+
    }
    1+
    0 &strs_mem pushc
    swap
}

// src_ptr --- new_src_ptr ref
:view_ident {
    &strs_mem headc swap
    viewc &strs_mem pushc
    while 1+ viewc {
        if viewc dup (is_alnum not) swap ('_' !=) & {
            0 &strs_mem pushc
            swap
            return
        }
        viewc &strs_mem pushc
    }
    0 &strs_mem pushc
    swap
}

// src_ptr --- new_src_ptr ref
:view_word {
    &strs_mem headc swap
    while ("(){}" over@c str_char not) (over@c is_space not) & (over@c bool) & {
        viewc &strs_mem pushc
        1+
    }
    0 &strs_mem pushc
    swap
}

#lex_trivial(trivial_char trivial_tok) {
    else if viewc trivial_char == {
        0 trivial_tok &toks_mem toks_push
        1+
    }
}

// src_ptr ---
:lex_src {
    while viewc {
        while viewc is_space { 1+ }
        if viewc not {
            return
        } else if ((viewc '-' ==) (over 1+ @c is_digit) &) (over@c is_digit) | {
            view_int TOK_INT &toks_mem toks_push
        } else if viewc '\'' == {
            view_char TOK_CHAR &toks_mem toks_push
        } else if viewc '\"' == {
            view_str TOK_STR &toks_mem toks_push
        }
        lex_trivial(':' TOK_COLON)
        lex_trivial('#' TOK_POUND)
        lex_trivial('$' TOK_DOLLAR)
        lex_trivial('(' TOK_PAREN_START)
        lex_trivial(')' TOK_PAREN_END)
        lex_trivial('{' TOK_BRACE_START)
        lex_trivial('}' TOK_BRACE_END)
        else if (viewc '&' ==) (over 1+ @c is_alpha) & {
            0 TOK_REF &toks_mem toks_push
            1+
        } else if (viewc '/' ==) (over 1+ @c '/' ==) & {
            while viewc dup ('\n' !=) swap (bool) & { 1+ }
        } else if viewc dup is_alpha swap ('_' ==) | {
            view_ident TOK_IDENT &toks_mem toks_push
        } else {
            view_word TOK_WORD &toks_mem toks_push
        }
    }
    drop
}

:main {
    $src_file_name: "src/lex.5th"

    $src_file 8
    &src_file_name 0 fopen &src_file!

    if &src_file@ is_failure {
        "ERROR: File '".s &src_file_name.s "' not found!\n".s
        1 exit
    }

    $src 8192
    &src 8192 &src_file@ fread drop
    &src_file@ fclose drop

    &src lex_src

    0 while dup &toks_mem len < {
        show ": ".s
        dup &toks_mem toks_get
        dup tok_kind. ": ".s
        dup tok_data.
        if dup tok_kind TOK_STR == {
            " (\"".s tok_data.s "\")".s cr
        } else if dup tok_kind TOK_WORD == {
            " (\"".s tok_data.s "\")".s cr
        } else if dup tok_kind TOK_IDENT == {
            " (\"".s tok_data.s "\")".s cr
        } else {
            drop cr
        }
        1+
    } drop
}

main