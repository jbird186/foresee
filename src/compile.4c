#include "std/stdstr.4c"
#include "std/stdchar.4c"
#include "src/config.4c"
#include "src/map.4c"

$static ptr out_fd

// ptr --
:coms {
    if dup str_len out_fd fwrite is_failure {
        "ERROR: Failed to write string to output file\n"eputs
        1 exit
    }
}
// int --
:com {
    if out_fd fwrite_int is_failure {
        "ERROR: Failed to write integer to output file\n"eputs
        1 exit
    }
}
// char --
:comc {
    $static char buf
    &buf!c
    if &buf 1 out_fd fwrite is_failure {
        "ERROR: Failed to write character to output file\n"eputs
        1 exit
    }
}

// item --
#compile_push_generic(com_type) {
    "    sub     "coms &stack_reg_str coms ", 8\n"coms
    "    mov     qword ["coms &stack_reg_str coms "], "coms com_type "\n" coms
}
// item --
:compile_push { compile_push_generic(coms) }
// item --
:compile_push_int { compile_push_generic(com) }
// --
:compile_stack_shrink {
    "    add     "coms &stack_reg_str coms ", 8\n" coms
}
// item --
:compile_pop {
    "    mov     "coms coms ", qword ["coms &stack_reg_str coms "]\n"coms
    compile_stack_shrink
}

:compile_ops

// name --
:compile_function {
    "; "coms dup coms "\n"coms
    "f_"coms dup &fns_map map_key_idx com ":\n"coms
    &fns_map map_get compile_ops
}

:compile_functions {
    // -- idx
    0 while dup MAP_SIZE < {
        // -- idx fn_name
        dup &fns_map map_get_idx_key
        if dup { compile_function }
        else { drop }
        1+
    } drop
}

// b_register instruction name --
:compile_basic_binop {
    "    ; "coms coms "\n"coms
    "rcx" compile_pop
    "rax" compile_pop
    "    "coms coms " \trax, "coms coms "\n"coms
    "rax" compile_push
}

// op_ptr -- new_op_ptr
:compile_op {
    if viewtk OP_NOOP == {}
    else if viewtk OP_EXIT == {
        "    ; OP_EXIT\n"coms
        "rdi" compile_pop
        "    mov     eax, 60\n"coms
        "    syscall\n"coms
    }
    else if viewtk OP_CALL == {
        "    ; OP_CALL\n"coms
        "    call f_"coms viewtd com "\n"coms
    }
    else if viewtk OP_RET == {
        "    ; OP_RET\n"coms
        "    ret\n"coms
    }
    else if viewtk OP_DROP == {
        "    ; OP_DROP\n"coms
        compile_stack_shrink
    }
    else if viewtk OP_PICK == {
        "    ; OP_PICK\n"coms
        "rax" compile_pop
        "    mov     rcx, ["coms &stack_reg_str coms " + rax*8]\n"coms
        "rcx" compile_push
    }
    else if viewtk OP_ROLL == {
        "    ; OP_ROLL\n"coms
        "rax" compile_pop
        "    mov     rcx, ["coms &stack_reg_str coms " + rax*8]\n"coms
        "    lea     rbx, ["coms &stack_reg_str coms " + rax*8]\n"coms
        "   .rl_"coms viewtd com ":\n"coms
        "    cmp     rbx, "coms &stack_reg_str coms "\n"coms
        "    je      .rl_"coms viewtd 1+ com "\n"coms
        "    mov     rdx, [rbx - 8]\n"coms
        "    mov     [rbx], rdx\n"coms
        "    sub     rbx, 8\n"coms
        "    jmp     .rl_"coms viewtd com "\n"coms
        "   .rl_"coms viewtd 1+ com ":\n"coms
        "    mov     ["coms &stack_reg_str coms "], rcx\n"coms
    }
    else if viewtk OP_DEPTH == {
        "    ; OP_DEPTH\n"coms
        "    mov     rax, b_stack + "coms &stack_size_str coms "\n"coms
        "    sub     rax, "coms &stack_reg_str coms "\n"coms
        "    shr     rax, 3\n"coms
        "rax" compile_push
    }
    else if viewtk OP_PUSH_INT == {
        "    ; OP_PUSH_INT\n"coms
        viewtd compile_push_int
    }
    else if viewtk OP_PUSH_BUF == {
        "    ; OP_PUSH_BUF\n"coms
        viewtd compile_push_generic({"b_"coms com})
    }
    else if viewtk OP_STORE == {
        "    ; OP_STORE\n"coms
        "rax" compile_pop
        "rcx" compile_pop
        "    mov     [rax], rcx\n"coms
    }
    else if viewtk OP_FETCH == {
        "    ; OP_FETCH\n"coms
        "rax" compile_pop
        "    mov     rbx, qword [rax]\n"coms
        "rbx" compile_push
    }
    else if viewtk OP_ADD == {
        "rcx" "add" "OP_ADD" compile_basic_binop
    }
    else if viewtk OP_SUB == {
        "rcx" "sub" "OP_SUB" compile_basic_binop
    }
    else if viewtk OP_MUL == {
        "rcx" "imul" "OP_MUL" compile_basic_binop
    }
    else if viewtk OP_DIV == {
        "    ; OP_DIV\n"coms
        "rbx" compile_pop
        "rax" compile_pop
        "    cqo\n"coms
        "    idiv    rbx\n"coms
        "rax" compile_push
    }
    else if viewtk OP_AND == {
        "rcx" "and" "OP_AND" compile_basic_binop
    }
    else if viewtk OP_OR == {
        "rcx" "or" "OP_OR" compile_basic_binop
    }
    else if viewtk OP_XOR == {
        "rcx" "xor" "OP_XOR" compile_basic_binop
    }
    else if viewtk OP_SHL == {
        "cl" "shl" "OP_SHL" compile_basic_binop
    }
    else if viewtk OP_SHR == {
        "cl" "shr" "OP_SHR" compile_basic_binop
    }
    else if viewtk OP_SAR == {
        "cl" "sar" "OP_SAR" compile_basic_binop
    }
    else if viewtk OP_NOT == {
        "    ; OP_NOT\n"coms
        "rax" compile_pop
        "    not     rax\n"coms
        "rax" compile_push
    }
    else if viewtk OP_EQ == {
        "    ; OP_EQ\n"coms
        "rbx" compile_pop
        "rax" compile_pop
        "    cmp     rax, rbx\n"coms
        "    sete    al\n"coms
        "    movzx   rax, al\n"coms
        "rax" compile_push
    }
    else if viewtk OP_GT == {
        "    ; OP_GT\n"coms
        "rbx" compile_pop
        "rax" compile_pop
        "    cmp     rax, rbx\n"coms
        "    setg    al\n"coms
        "    movzx   rax, al\n"coms
        "rax" compile_push
    }
    else if viewtk OP_LT == {
        "    ; OP_LT\n"coms
        "rbx" compile_pop
        "rax" compile_pop
        "    cmp     rax, rbx\n"coms
        "    setl    al\n"coms
        "    movzx   rax, al\n"coms
        "rax" compile_push
    }
    else if viewtk OP_LABEL == {
        ".l_"coms viewtd com ":\n"coms
    }
    else if viewtk OP_JMP == {
        "    ; OP_JMP\n"coms
        "    jmp     .l_"coms viewtd com "\n"coms
    }
    else if viewtk OP_JZ == {
        "    ; OP_JZ\n"coms
        "rax" compile_pop
        "    test    rax, rax\n"coms
        "    jz     .l_"coms viewtd com "\n"coms
    }
    else if viewtk OP_FOPEN == {
        "    ; OP_FOPEN\n"coms
        "rsi" compile_pop         // mode (0 = read, 1 = write, etc.)
        "rdi" compile_pop         // filename pointer
        "    mov     rax, 2\n"coms
        "    cmp     rsi, 0\n"coms
        "    je      .frl_"coms viewtd com "\n"coms
        "    cmp     rsi, 1\n"coms
        "    je      .fwl_"coms viewtd com "\n"coms
        "    cmp     rsi, 2\n"coms
        "    je      .fal_"coms viewtd com "\n"coms
        "    jmp     .ffl_"coms viewtd com "\n"coms
        "    .frl_"coms viewtd com ":\n"coms
        "    mov     rsi, 0\n"coms
        "    jmp     .fdl_"coms viewtd com "\n"coms
        "    .fwl_"coms viewtd com ":\n"coms
        "    mov     rsi, 577\n"coms
        "    jmp     .fdl_"coms viewtd com "\n"coms
        "    .fal_"coms viewtd com ":\n"coms
        "    mov     rsi, 1025\n"coms
        "    jmp     .fdl_"coms viewtd com "\n"coms
        "    .fdl_"coms viewtd com ":\n"coms
        "    mov     rdx, 420\n"coms
        "    syscall\n"coms
        "rax" compile_push        // push FD (or -1 on error)
        "    jmp     .fel_"coms viewtd com "\n"coms
        "    .ffl_"coms viewtd com ":\n"coms
        "    mov     rax, -1\n"coms
        "rax" compile_push
        "    .fel_"coms viewtd com ":\n"coms
    }
    else if viewtk OP_FREAD == {
        "    ; OP_FREAD\n"coms
        "rdi" compile_pop           // file descriptor
        "rdx" compile_pop           // length
        "rsi" compile_pop           // buffer pointer
        "    mov     rax, 0\n"coms // sys_read
        "    syscall\n"coms
        "rax" compile_push          // bytes read or -1
    }
    else if viewtk OP_FWRITE == {
        "    ; OP_FWRITE\n"coms
        "rdi" compile_pop           // file descriptor
        "rdx" compile_pop           // length
        "rsi" compile_pop           // buffer pointer
        "    mov     rax, 1\n"coms // sys_write
        "    syscall\n"coms
        "rax" compile_push          // bytes written or -1
    }
    else if viewtk OP_FCLOSE == {
        "    ; OP_FCLOSE\n"coms
        "rdi" compile_pop           // file descriptor
        "    mov     rax, 3\n"coms // sys_close
        "    syscall\n"coms
        "rax" compile_push          // return 0 or -1
    }
    else {
        "ERROR: Invalid opcode of type "eputs viewtk eput cr
        1 exit
    }
    tok_next
}

// op_ptr --
:compile_ops {
    while viewtk { compile_op }
    drop
}

// char -- bool
:should_print_char {
    dup is_print
    swap (dup ('\\' !=) swap ('"' !=) &) &
    USE_ASM_STRINGS &
}

// init --
:compile_buf_str {
    $static char is_quote
    false =is_quote

    while dup@c {
        if dup@c should_print_char {
            if is_quote not {
                '"' comc
                true =is_quote
            }
            dup@c comc
        } else {
            if is_quote {
                "\","coms
                false =is_quote
            }
            dup@c com
            ","coms
        }
        1+
    } drop

    if is_quote {
        "\","coms
    }
    "0\n" coms
}

:compile_inline_bufs {
    "    ; Inline Buffers\n"coms
    // -- idx
    0 while dup &inline_bufs stack_len < {
        "    b_"coms dup MAP_SIZE+ com " db "coms
        dup &inline_bufs stack_get compile_buf_str
        1+
    } drop
}

// idx --
:compile_buf_data {
    $static int buf_size
    dup bmap_idx_size if dup 0 < { -1* } =buf_size

    "    ; "coms dup bmap_idx_name coms "\n"coms
    "    b_"coms dup com

    if dup bmap_idx_size 0 < {
        if buf_size 1 == {
            " db "coms bmap_idx_init com "\n"coms
        } else if buf_size 8 == {
            " dq "coms bmap_idx_init com "\n"coms
        }
    } else {
        " db "coms
        dup bmap_idx_init compile_buf_str
        if (dup bmap_idx_init str_len 1+) (buf_size) < {
            "        times "coms buf_size com " - ($ - b_"coms dup com ") db 0\n"coms
        }
        drop
    }
}

// idx --
:compile_buf_bss {
    "    b_"coms dup com " resb "coms bmap_idx_size com
    " ; "coms dup bmap_idx_name coms "\n" coms
}

// idx -- bool
:use_section_data {
    dup (bmap_idx_init flag) swap (bmap_idx_size 0 <) |
}

:compile_program {
    "BITS 64\n"coms
    "global _start\n"coms
    "section .text\n"coms
    compile_functions

    "; start\n"coms
    "_start:\n"coms
    "    lea     "coms &stack_reg_str coms ", [b_stack + "coms &stack_size_str coms "]\n"coms
    "    lea     rdi, [rsp + 8]\n"coms
    "rdi" compile_push
    "    mov     rdi, [rsp]\n"coms
    "rdi" compile_push
    &start_ops_mem tok_first compile_ops

    "section .data\n"coms
    // -- idx
    0 while dup MAP_SIZE < {
        if dup dup (bmap_idx_name flag) swap (use_section_data) & {
            dup compile_buf_data
        }
        1+
    } drop
    compile_inline_bufs

    "section .bss\n"coms
    // -- idx
    0 while dup MAP_SIZE < {
        if dup dup (bmap_idx_name flag) swap (use_section_data not) & {
            dup compile_buf_bss
        }
        1+
    } drop
    "    b_stack: resb "coms &stack_size_str coms " ; Stack Pointer\n" coms
}