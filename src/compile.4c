#include "std/stdstr.4c"
#include "src/config.4c"
#include "src/map.4c"

$out_fd REF

// ptr ---
:compile_str {
    if dup str_len &out_fd@ fwrite is_failure {
        "ERROR: Failed to write string to output file\n".s
        1 exit
    }
}
#.coms{compile_str}
// int ---
:compile_int {
    if &out_fd@ fwrite_int is_failure {
        "ERROR: Failed to write integer to output file\n".s
        1 exit
    }
}
#.com{compile_int}

// item ---
#compile_push_generic(com_type) {
    "    sub     ".coms &stack_ptr_str.coms ", 8\n".coms
    "    mov     qword [".coms &stack_ptr_str.coms "], ".coms com_type "\n".coms
}
// item ---
:compile_push { compile_push_generic({.coms}) }
// item ---
:compile_push_int { compile_push_generic({.com}) }
// ---
:compile_stack_shrink {
    "    add     ".coms &stack_ptr_str.coms ", 8\n".coms
}
// item ---
:compile_pop {
    "    mov     ".coms .coms ", qword [".coms &stack_ptr_str.coms "]\n".coms
    compile_stack_shrink
}

:compile_ops

// name ---
:compile_function {
    "; ".coms dup.coms "\n".coms
    "f_".coms dup &fns_map map_key_idx.com ":\n".coms
    &fns_map map_get compile_ops
}

:compile_functions {
    // idx
    0 while dup MAP_SIZE < {
        // idx fn_name
        dup &fns_map map_get_idx_key
        if dup { compile_function }
        else { drop }
        1+
    } drop
}

// b_register instruction name ---
:compile_basic_binop {
    "    ; ".coms .coms "\n".coms
    "rcx" compile_pop
    "rax" compile_pop
    "    ".coms .coms " \trax, ".coms .coms "\n".coms
    "rax" compile_push
}

// op_ptr --- new_op_ptr
:compile_op {
    if viewtk OP_NOOP == {}
    else if viewtk OP_EXIT == {
        "    ; OP_EXIT\n".coms
        "rdi" compile_pop
        "    mov     eax, 60\n".coms
        "    syscall\n".coms
    }
    else if viewtk OP_CALL == {
        "    ; OP_CALL\n".coms
        "    call f_".coms viewtd.com "\n".coms
    }
    else if viewtk OP_RET == {
        "    ; OP_RET\n".coms
        "    ret\n".coms
    }
    else if viewtk OP_DROP == {
        "    ; OP_DROP\n".coms
        compile_stack_shrink
    }
    else if viewtk OP_PICK == {
        "    ; OP_PICK\n".coms
        "rax" compile_pop
        "    mov     rcx, [".coms &stack_ptr_str.coms " + rax*8]\n".coms
        "rcx" compile_push
    }
    else if viewtk OP_ROLL == {
        "    ; OP_ROLL\n".coms
        "rax" compile_pop
        "    mov     rcx, [".coms &stack_ptr_str.coms " + rax*8]\n".coms
        "    lea     rbx, [".coms &stack_ptr_str.coms " + rax*8]\n".coms
        "   .rl_".coms viewtd.com ":\n".coms
        "    cmp     rbx, ".coms &stack_ptr_str.coms "\n".coms
        "    je      .rl_".coms viewtd 1+ .com "\n".coms
        "    mov     rdx, [rbx - 8]\n".coms
        "    mov     [rbx], rdx\n".coms
        "    sub     rbx, 8\n".coms
        "    jmp     .rl_".coms viewtd.com "\n".coms
        "   .rl_".coms viewtd 1+ .com ":\n".coms
        "    mov     [".coms &stack_ptr_str.coms "], rcx\n".coms
    }
    else if viewtk OP_DEPTH == {
        "    ; OP_DEPTH\n".coms
        "    mov     rax, __stack_ptr + ".coms &stack_sz_ptr.coms "\n".coms
        "    sub     rax, ".coms &stack_ptr_str.coms "\n".coms
        "    shr     rax, 3\n".coms
        "rax" compile_push
    }
    else if viewtk OP_PUSH_INT == {
        "    ; OP_PUSH_INT\n".coms
        viewtd compile_push_int
    }
    else if viewtk OP_PUSH_BUF == {
        "    ; OP_PUSH_BUF\n".coms
        viewtd compile_push_generic({"b_".coms .com})
    }
    else if viewtk OP_STORE == {
        "    ; OP_STORE\n".coms
        "rax" compile_pop
        "rcx" compile_pop
        "    mov     [rax], rcx\n".coms
    }
    else if viewtk OP_FETCH == {
        "    ; OP_FETCH\n".coms
        "rax" compile_pop
        "    mov     rbx, qword [rax]\n".coms
        "rbx" compile_push
    }
    else if viewtk OP_ADD == {
        "rcx" "add" "OP_ADD" compile_basic_binop
    }
    else if viewtk OP_SUB == {
        "rcx" "sub" "OP_SUB" compile_basic_binop
    }
    else if viewtk OP_MUL == {
        "rcx" "imul" "OP_MUL" compile_basic_binop
    }
    else if viewtk OP_DIV == {
        "    ; OP_DIV\n".coms
        "rbx" compile_pop
        "rax" compile_pop
        "    cqo\n".coms
        "    idiv    rbx\n".coms
        "rax" compile_push
    }
    else if viewtk OP_AND == {
        "rcx" "and" "OP_AND" compile_basic_binop
    }
    else if viewtk OP_OR == {
        "rcx" "or" "OP_OR" compile_basic_binop
    }
    else if viewtk OP_XOR == {
        "rcx" "xor" "OP_XOR" compile_basic_binop
    }
    else if viewtk OP_SHL == {
        "cl" "shl" "OP_SHL" compile_basic_binop
    }
    else if viewtk OP_SHR == {
        "cl" "shr" "OP_SHR" compile_basic_binop
    }
    else if viewtk OP_SAR == {
        "cl" "sar" "OP_SAR" compile_basic_binop
    }
    else if viewtk OP_NOT == {
        "    ; OP_NOT\n".coms
        "rax" compile_pop
        "    not     rax\n".coms
        "rax" compile_push
    }
    else if viewtk OP_EQ == {
        "    ; OP_EQ\n".coms
        "rbx" compile_pop
        "rax" compile_pop
        "    cmp     rax, rbx\n".coms
        "    sete    al\n".coms
        "    movzx   rax, al\n".coms
        "rax" compile_push
    }
    else if viewtk OP_GT == {
        "    ; OP_GT\n".coms
        "rbx" compile_pop
        "rax" compile_pop
        "    cmp     rax, rbx\n".coms
        "    setg    al\n".coms
        "    movzx   rax, al\n".coms
        "rax" compile_push
    }
    else if viewtk OP_LT == {
        "    ; OP_LT\n".coms
        "rbx" compile_pop
        "rax" compile_pop
        "    cmp     rax, rbx\n".coms
        "    setl    al\n".coms
        "    movzx   rax, al\n".coms
        "rax" compile_push
    }
    else if viewtk OP_LABEL == {
        ".l_".coms viewtd.com ":\n".coms
    }
    else if viewtk OP_JMP == {
        "    ; OP_JMP\n".coms
        "    jmp     .l_".coms viewtd.com "\n".coms
    }
    else if viewtk OP_JZ == {
        "    ; OP_JZ\n".coms
        "rax" compile_pop
        "    test    rax, rax\n".coms
        "    jz     .l_".coms viewtd.com "\n".coms
    }
    else if viewtk OP_FOPEN == {
        "    ; OP_FOPEN\n".coms
        "rsi" compile_pop         // mode (0 = read, 1 = write, etc.)
        "rdi" compile_pop         // filename pointer
        "    mov     rax, 2\n".coms
        "    cmp     rsi, 0\n".coms
        "    je      .frl_".coms viewtd.com "\n".coms
        "    cmp     rsi, 1\n".coms
        "    je      .fwl_".coms viewtd.com "\n".coms
        "    cmp     rsi, 2\n".coms
        "    je      .fal_".coms viewtd.com "\n".coms
        "    jmp     .ffl_".coms viewtd.com "\n".coms
        "    .frl_".coms viewtd.com ":\n".coms
        "    mov     rsi, 0\n".coms
        "    jmp     .fdl_".coms viewtd.com "\n".coms
        "    .fwl_".coms viewtd.com ":\n".coms
        "    mov     rsi, 577\n".coms
        "    jmp     .fdl_".coms viewtd.com "\n".coms
        "    .fal_".coms viewtd.com ":\n".coms
        "    mov     rsi, 1025\n".coms
        "    jmp     .fdl_".coms viewtd.com "\n".coms
        "    .fdl_".coms viewtd.com ":\n".coms
        "    mov     rdx, 420\n".coms
        "    syscall\n".coms
        "rax" compile_push        // push FD (or -1 on error)
        "    jmp     .fel_".coms viewtd.com "\n".coms
        "    .ffl_".coms viewtd.com ":\n".coms
        "    mov     rax, -1\n".coms
        "rax" compile_push
        "    .fel_".coms viewtd.com ":\n".coms
    }
    else if viewtk OP_FREAD == {
        "    ; OP_FREAD\n".coms
        "rdi" compile_pop           // file descriptor
        "rdx" compile_pop           // length
        "rsi" compile_pop           // buffer pointer
        "    mov     rax, 0\n".coms // sys_read
        "    syscall\n".coms
        "rax" compile_push          // bytes read or -1
    }
    else if viewtk OP_FWRITE == {
        "    ; OP_FWRITE\n".coms
        "rdi" compile_pop           // file descriptor
        "rdx" compile_pop           // length
        "rsi" compile_pop           // buffer pointer
        "    mov     rax, 1\n".coms // sys_write
        "    syscall\n".coms
        "rax" compile_push          // bytes written or -1
    }
    else if viewtk OP_FCLOSE == {
        "    ; OP_FCLOSE\n".coms
        "rdi" compile_pop           // file descriptor
        "    mov     rax, 3\n".coms // sys_close
        "    syscall\n".coms
        "rax" compile_push          // return 0 or -1
    }
    else {
        "ERROR: Invalid opcode of type ".s viewtk. cr
        1 exit
    }
    tok_next
}

// op_ptr ---
:compile_ops {
    while viewtk { compile_op }
    drop
}

:compile_inline_bufs {
    "    ; Inline Buffers\n".coms
    // idx
    0 while dup &inline_bufs len < {
        "    b_".coms dup MAP_SIZE+ .com " db ".coms
        // idx init
        dup &inline_bufs get
        while dup@c {
            dup@c .com
            1+
            ",".coms
        }
        "0".coms
        // idx
        drop "\n".coms
        1+
    } drop
}

// name ---
:compile_buf_data {
    "    ; $".coms dup.coms " ".coms dup &bufs_size_map map_get.com "\n".coms
    "    b_".coms dup &bufs_size_map map_key_idx.com " db ".coms

    // name init
    dup &bufs_init_map map_get
    while dup@c {
        dup@c .com
        1+
        ",".coms
    }
    "0".coms
    // name
    drop "\n".coms
    // name
    if dup dup (&bufs_size_map map_get) swap (&bufs_init_map map_get str_len 1+) > {
        "        times ".coms
        dup &bufs_size_map map_get.com
        " - ($ - b_".coms
        dup &bufs_size_map map_key_idx.com
        ") db 0\n".coms
    }
    drop
}

// name ---
:compile_buf_bss {
    "    ; $".coms
    dup.coms
    "\n".coms

    "    b_".coms
    dup &bufs_size_map map_key_idx.com
    " resb ".coms
    &bufs_size_map map_get.com
    "\n".coms
}

:compile_program {
    "BITS 64\n".coms
    "global _start\n".coms
    "section .text\n".coms
    compile_functions

    "_start:\n".coms
    "    lea     ".coms &stack_ptr_str.coms ", [__stack_ptr + ".coms &stack_sz_ptr.coms "]\n".coms
    &start_ops_mem tok_first compile_ops

    "section .data\n".coms
    // idx
    0 while dup MAP_SIZE < {
        // idx key
        dup &bufs_size_map map_get_idx_key
        if dup {
            if dup &bufs_init_map map_get {
                compile_buf_data
            } else { drop }
        } else { drop }
        1+
    } drop
    compile_inline_bufs

    "section .bss\n".coms
    // idx
    0 while dup MAP_SIZE < {
        // idx key
        dup &bufs_size_map map_get_idx_key
        if dup {
            if dup &bufs_init_map map_get not {
                compile_buf_bss
            } else { drop }
        } else { drop }
        1+
    } drop

    "    ; Stack Pointer\n".coms
    "    __stack_ptr: resb ".coms &stack_sz_ptr.coms "\n".coms
}