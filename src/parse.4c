#use "stdstr.4c"
#use "config.4c"
#use "token.4c"
#use "op.4c"

$static int ASM_LABEL_ID
$static int FN_ALLOC_SIZE

:parse_tok

// ops_dest tok_ptr -- ops_dest tok_ptr
#macro _parse_until(until_tok_kind) {
    while viewtk until_tok_kind != {
        over swap parse_tok
    }
    %Token+
}

// ops_dest tok_ptr idx -- ops_dest tok_ptr
:push_buf_ptr {
    if dup BUF_MAP map_idx->Buffer.is_static@c {
        OKind.PUSH_BUF 3 pick op_push
    } else {
        BUF_MAP map_idx
        dup->Buffer.alloc_offset@
        swap->Buffer.size@ +
        OKind.PUSH_VAR 3 pick op_push
    }
}

// name scope --
:check_name_availability_fn {
    if over over BUF_MAP scoped_map_get slot_is_used {
        error "Buffer '"eputs over eputs "' already defined in this scope\n"eputs
        1 exit
    }
    if over over STRUCT_MAP scoped_map_get slot_is_used {
        error "Struct '"eputs over eputs "' already defined in this scope\n"eputs
        1 exit
    }
    if over over ENUM_MAP scoped_map_get slot_is_used {
        error "Enum '"eputs over eputs "' already defined in this scope\n"eputs
        1 exit
    }
    drop drop
}

// name scope --
:check_name_availability {
    if over over FN_MAP scoped_map_get slot_is_used {
        error "Function '"eputs over eputs "' already defined in this scope\n"eputs
        1 exit
    }
    check_name_availability_fn
}

// ops_dest tok_ptr type_name -- ops_dest new_tok_ptr type_name field_size offset should_chain
:view_field_access {
    $ptr struct_name: {}

    // -- ops_dest tok_ptr
    if struct_name STRUCT_MAP scoped_map_find_idx is_failure {
        error "Unrecognized struct '"eputs struct_name eputs "'\n"eputs
        1 exit
    }
    // -- ops_dest fields_ptr tok_ptr
    struct_name STRUCT_MAP scoped_map_find->Struct.fields@ swap
    if viewtk TKind.FIELD != {
        error "Expected field access after '->"eputs struct_name eputs "'\n"eputs
        1 exit
    }
    %Token+

    // -- ops_dest tok_ptr field_name fields_ptr
    viewtd rot
    $int sum: {0}
    while dup->StructField.name@ {
        if over over->StructField.name@ streq {
            // -- ops_dest tok_ptr fields_ptr
            nip swap %Token+ swap
            // -- ops_dest tok_ptr type_name field_size offset
            dup->StructField.type_name@ swap->StructField.size@ sum
            3 pick->Token.kind@c TKind.FIELD ==
            return
        }
        dup->StructField.size@ sum + =sum
        %StructField+
    }

    drop
    swap error swap "Field '"eputs eputs "' not found for struct '"eputs struct_name eputs "'\n"eputs
    1 exit
}

// ops_dest tok_ptr -- ops_dest new_tok_ptr name size
:view_buffer_access {
    $int idx
    $int name
    $int size

    // ops_dest tok_ptr type_name -- ops_dest new_tok_ptr
    #macro view_fields {
        // -- ops_dest new_tok_ptr type_name field_size offset
        while view_field_access {
            // -- ops_dest new_tok_ptr type_name offset
            swap =size
            OKind.PUSH_INT 4 pick op_push
            0 OKind.ADD 4 pick op_push
        }

        // -- ops_dest new_tok_ptr offset
        swap =size nip
        OKind.PUSH_INT 3 pick op_push
        0 OKind.ADD 3 pick op_push
    }

    viewtd dup BUF_MAP scoped_map_find_idx =idx =name
    if idx is_failure {
        error "Buffer '"eputs name eputs "' not defined in this scope\n"eputs
        1 exit
    }

    %Token+
    idx BUF_MAP map_idx->Buffer.size@ =size
    idx push_buf_ptr

    if viewtk TKind.FIELD == {
        // -- ops_dest new_tok_ptr type_name
        idx BUF_MAP map_idx->Buffer.type_name@
        view_fields
    }
    name size
}

// ops_dest tok_ptr -- ops_dest tok_ptr
:call_storec {
    if "storec" FN_MAP scoped_map_find_idx is_failure {
        error "Function 'storec' not defined\n"eputs
        1 exit
    }
    "storec" FN_MAP scoped_map_find_idx OKind.CALL_FN 3 pick op_push
}

// ops_dest tok_ptr -- ops_dest tok_ptr
:call_fetchc {
    if "fetchc" FN_MAP scoped_map_find_idx is_failure {
        error "Function 'fetchc' not defined\n"eputs
        1 exit
    }
    "fetchc" FN_MAP scoped_map_find_idx OKind.CALL_FN 3 pick op_push
}

// ops_dest tok_ptr -- new_tok_ptr
:parse_string {
    viewtd &inline_bufs %ptr stack_push!
    // -- tok_ptr
    &inline_bufs stack_len 1- MAP_SIZE+ OKind.PUSH_BUF 3 roll op_push
    %Token+
}

// ops_dest tok_ptr -- new_tok_ptr
:parse_ident {
    ////////// Intrinsics //////////
    #macro define_intrinsic_opcode(data op_code alias) {
        if viewtd alias streq {
            // -- tok_ptr
            (data) op_code 3 roll op_push
            %Token+
            return
        }
    }
    // Misc / Special
    define_intrinsic_opcode(0 {OKind.NOOP} "__OP_NOOP")
    define_intrinsic_opcode(0 {OKind.EXIT} "__OP_EXIT")
    // Functions
    define_intrinsic_opcode(0 {OKind.RET} "__OP_RET")
    // Stack Primitives
    define_intrinsic_opcode(0 {OKind.DROP} "__OP_DROP")
    define_intrinsic_opcode(0 {OKind.PICK} "__OP_PICK")
    define_intrinsic_opcode({&ASM_LABEL_ID@++} {OKind.ROLL} "__OP_ROLL")
    define_intrinsic_opcode(0 {OKind.DEPTH} "__OP_DEPTH")
    // Reference Primitives
    define_intrinsic_opcode(0 {OKind.STORE} "__OP_STORE")
    define_intrinsic_opcode(0 {OKind.FETCH} "__OP_FETCH")
    // Binary Operations
    define_intrinsic_opcode(0 {OKind.ADD} "__OP_ADD")
    define_intrinsic_opcode(0 {OKind.SUB} "__OP_SUB")
    define_intrinsic_opcode(0 {OKind.MUL} "__OP_MUL")
    define_intrinsic_opcode(0 {OKind.AND} "__OP_AND")
    define_intrinsic_opcode(0 {OKind.OR} "__OP_OR")
    define_intrinsic_opcode(0 {OKind.XOR} "__OP_XOR")
    define_intrinsic_opcode(0 {OKind.SHL} "__OP_SHL")
    define_intrinsic_opcode(0 {OKind.SHR} "__OP_SHR")
    define_intrinsic_opcode(0 {OKind.SAR} "__OP_SAR")
    define_intrinsic_opcode(0 {OKind.NOT} "__OP_NOT")
    define_intrinsic_opcode(0 {OKind.EQ} "__OP_EQ")
    define_intrinsic_opcode(0 {OKind.GT} "__OP_GT")
    define_intrinsic_opcode(0 {OKind.LT} "__OP_LT")
    define_intrinsic_opcode(0 {OKind.DIVMOD} "__OP_DIVMOD")
    // I/O
    define_intrinsic_opcode({&ASM_LABEL_ID@++} {OKind.FOPEN} "__OP_FOPEN")
    define_intrinsic_opcode(0 {OKind.FREAD} "__OP_FREAD")
    define_intrinsic_opcode(0 {OKind.FWRITE} "__OP_FWRITE")
    define_intrinsic_opcode(0 {OKind.FCLOSE} "__OP_FCLOSE")

    ////////// Functions //////////
    if viewtd FN_MAP scoped_map_find_idx is_success {
        viewtd FN_MAP scoped_map_find_idx OKind.CALL_FN 3 roll op_push
        %Token+
        return
    }

    ////////// Enums //////////
    if viewtd ENUM_MAP scoped_map_find_idx is_success {
        $int name: {viewtd}

        // -- ops_dest tok_ptr variants
        name ENUM_MAP scoped_map_find->Enum.variants@
        // -- ops_dest variants tok_ptr
        swap %Token+
        if viewtk TKind.FIELD != {
            error "Expected variant after '"eputs name eputs "'\n"eputs
            1 exit
        }
        %Token+
        // -- ops_dest tok_ptr name variants
        viewtd rot
        while dup->EnumVariant.name@ {
            if over over->EnumVariant.name@ streq {
                nip->EnumVariant.value@ OKind.PUSH_INT 3 roll op_push
                %Token+
                return
            }
            %EnumVariant+
        }
        drop
        swap error swap "Field '"eputs eputs "' not found for enum '"eputs name eputs "'\n"eputs
        1 exit
    }

    ////////// Buffers //////////
    // -- ops_dest tok_ptr name size
    view_buffer_access
    if dup 8 == {
        drop drop
        0 OKind.FETCH 3 roll op_push
    } else if dup 1 == {
        drop drop call_fetchc nip
    } else {
        rot error "Buffer '"eputs rot eputs "' ("eputs swap eput " bytes) cannot be automatically read from\n"eputs
        1 exit
    }
}

// ops_dest tok_ptr if_id -- new_tok_ptr
:_parse_if_with_id {
    // -- ops_dest tok_ptr if_id else_id
    &ASM_LABEL_ID@++
    // -- if_id else_id ops_dest tok_ptr
    3 roll 3 roll
    %Token+
    // Condition
    _parse_until({TKind.BRACE_START})
    // -- if_id else_id ops_dest tok_ptr
    2 pick OKind.JZ 3 pick op_push

    // Operations
    dup SCOPE_STACK stack_push!
    _parse_until({TKind.BRACE_END})
    &scope_stack stack_shrink

    // -- if_id else_id ops_dest tok_ptr
    3 pick OKind.JMP 3 pick op_push
    2 pick OKind.LABEL 3 pick op_push
    // -- if_id ops_dest tok_ptr
    rot drop

    // No else condition
    if viewtk TKind.ELSE != {
        // tok_ptr
        nip nip
        return
    }
    %Token+

    // Else condition
    // -- if_id ops_dest tok_ptr
    if viewtk TKind.BRACE_START == {
        %Token+
        dup SCOPE_STACK stack_push!
        _parse_until({TKind.BRACE_END})
        &scope_stack stack_shrink
        nip nip
    } else if viewtk TKind.IF == {
        // -- tok_ptr
        rot _parse_if_with_id
    } else {
        error "Invalid 'if' condition\n"eputs
        1 exit
    }
}

// ops_dest tok_ptr -- new_tok_ptr
:parse_if {
    // -- ops_dest if_id tok_ptr
    &ASM_LABEL_ID@++ swap
    // -- ops_dest if_id tok_ptr
    2 pick swap 2 pick _parse_if_with_id
    // -- tok_ptr
    swap OKind.LABEL 3 roll op_push
}

// ops_dest tok_ptr -- new_tok_ptr
:parse_while {
    %Token+

    // -- start_id ops_dest tok_ptr
    ASM_LABEL_ID dup 2+ =ASM_LABEL_ID rot rot
    2 pick OKind.LABEL 3 pick op_push

    // Condition
    _parse_until({TKind.BRACE_START})
    2 pick 1+ OKind.JZ 3 pick op_push

    // Operations
    dup SCOPE_STACK stack_push!
    _parse_until({TKind.BRACE_END})
    &scope_stack stack_shrink

    2 pick OKind.JMP 3 pick op_push
    rot 1+ OKind.LABEL 3 roll op_push
}

// ops_dest tok_ptr -- new_tok_ptr
:parse_fn {
    %Token+
    $int scope: { SCOPE_STACK stack_last@ }
    if viewtk TKind.PUB == {
        NULL =scope
        %Token+
    }

    // -- tok_ptr
    if swap {
        error "Function '"eputs viewtd eputs "' must be defined in global scope\n"eputs
        1 exit
    }

    $ptr name: {viewtd}
    %Token+

    name scope check_name_availability_fn
    if name scope FN_MAP scoped_map_get->Function.def@ {
        error "Function '"eputs name eputs "' already defined in this scope\n"eputs
        1 exit
    }

    // Function prototype
    if viewtk TKind.BRACE_START != {
        name scope FN_MAP scoped_map_get
        name over->Function.key.name!
        scope swap->Function.key.scope!
        return
    }

    $ptr fn_ptr: {&fn_ops_mem %Op stack_top}
    name scope FN_MAP scoped_map_get
    name over->Function.key.name!
    scope over->Function.key.scope!
    fn_ptr swap->Function.def!
    %Token+

    // 0 =ASM_LABEL_ID
    0 =FN_ALLOC_SIZE
    0 OKind.ALLOC &fn_ops_mem op_push
    dup SCOPE_STACK stack_push!
    while viewtk TKind.BRACE_END != {
        &fn_ops_mem swap parse_tok
    }
    %Token+

    if &fn_ops_mem %Op stack_last->Token.kind@c OKind.RET != {
        0 OKind.RET &fn_ops_mem op_push
    }

    // fn_ops tok_ptr
    &scope_stack stack_shrink
    FN_ALLOC_SIZE &fn_ptr@ ->Op.data!
    0 OKind.EOF &fn_ops_mem op_push
}

:view_buf_size

// base tok_ptr -- total tok_ptr
:view_buf_size_scalar {
    while viewtk TKind.BRACKET_START == {
        // -- total tok_ptr scalar
        %Token+ view_buf_size
        // -- total tok_ptr
        rot * swap
        if viewtk TKind.BRACKET_END != {
            error "Invalid buffer size\n"eputs
            1 exit
        }
        %Token+
    }
}

// tok_ptr -- new_tok_ptr size
:view_type_size {
    if viewtd STRUCT_MAP scoped_map_find dup slot_is_empty {
        drop
        error "Type '"eputs viewtd eputs "' not found\n"eputs
        1 exit
    }
    ->Struct.fields@

    // -- tok_ptr sum fields
    0 swap while dup->StructField.name@ {
        dup->StructField.size@ rot+ swap
        %StructField+
    }
    drop
}

// tok_ptr -- new_tok_ptr int
:view_buf_size_int {
    if viewtk TKind.INT == {
        // -- base tok_ptr
        viewtd swap %Token+
        view_buf_size_scalar
    } else if viewtk TKind.IDENT == {
        // -- sum tok_ptr
        view_type_size swap %Token+
        view_buf_size_scalar
    } else {
        // -- value tok_ptr
        %Token+ view_buf_size swap
        if viewtk TKind.BRACKET_END != {
            error "Invalid buffer size\n"eputs
            1 exit
        }
        %Token+
    }

    if over 0 < {
		error "Invalid buffer size\n"eputs
		1 exit
	}
    swap
}

// tok_ptr -- bool
:tok_is_type {
    if viewtk TKind.IDENT != {
        drop false return
    }
    ->Token.data@ STRUCT_MAP scoped_map_find_idx is_success
}

// tok_ptr -- new_tok_ptr size
:view_buf_size {
	// -- sum tok_ptr
	0 swap while (viewtk TKind.INT ==) (over tok_is_type) | {
		view_buf_size_int rot + swap
	}

    if over 0 < {
		error "Invalid buffer size\n"eputs
		1 exit
	}
    swap
}

#macro _parse_dollar_non_static_init {
    if viewtk TKind.BRACE_START == {
        %Token+
        if (size 1 ==) (size 8 ==) | not {
            error "Buffer '"eputs name eputs "' ("eputs size eput " bytes) cannot be automatically assigned to\n"eputs
            1 exit
        }

        dup SCOPE_STACK stack_push!
        _parse_until({TKind.BRACE_END})
        &scope_stack stack_shrink

        alloc_offset size+ OKind.PUSH_VAR 3 pick op_push
        if size 1 == {
            call_storec
        } else {
            0 OKind.STORE 3 pick op_push
        }
    } else {
        error "Non-static buffers can only utilize block initialization\n"eputs
        1 exit
    }
}

#macro _parse_dollar_static_init {
    if viewtk TKind.STR == {
        // -- tok_ptr str_size
        viewtd strlen 1+
        if size 0 < {
            =size
        } else if size > {
            error "Invalid size for buffer '"eputs name eputs "'\n"eputs
            1 exit
        }
        false =init_int
    } else if viewtk TKind.INT == {
        if size 0 < {
            8 =size
        } else {
            if size 8 == {}
            else if (viewtd dup (0xff <=) swap (0 >=) &) (size 1 ==) & {}
            else {
                error "Invalid size for buffer '"eputs name eputs "'\n"eputs
                1 exit
            }
        }
        true =init_int
    } else if viewtk TKind.CHAR == {
        if size 0 < {
            1 =size
        } else {
            if (size 8 !=) (size 1 !=) & {
                error "Invalid size for buffer '"eputs name eputs "'\n"eputs
                1 exit
            }
        }
        true =init_int
    } else {
        error "Invalid initialization value for buffer '"eputs name eputs "'\n"eputs
        1 exit
    }
    viewtd =init
    %Token+
}

// ops_dest tok_ptr -- new_tok_ptr
:parse_dollar {
    %Token+
    $int scope: { SCOPE_STACK stack_last@ }
    if viewtk TKind.PUB == {
        NULL =scope
        %Token+
    }

    $char is_static
    $int alloc_offset
    if viewtk TKind.STATIC == {
        true =is_static
        0 =alloc_offset
        %Token+
    } else {
        if over not {
            error "Buffers defined at global scope must be static\n"eputs
            1 exit
        }
        false =is_static
        FN_ALLOC_SIZE =alloc_offset
    }

    $int size
    $ptr type_name: {NULL}
    if dup tok_is_type {
        // -- type_name tok_ptr
        viewtd swap
        // -- type_name tok_ptr n_toks
        dup view_buf_size =size dup rot - %Token/
        if 1 == { swap =type_name } else { nip }
    } else if viewtk TKind.INT == {
        view_buf_size =size
    } else {
        -1 =size
    }

    if is_static not {
        FN_ALLOC_SIZE size+ =FN_ALLOC_SIZE
    }

    if viewtk TKind.IDENT != {
        error "Invalid buffer name\n"eputs
        1 exit
    }
    $ptr name: {viewtd}
    name scope check_name_availability

    %Token+
    $ptr init
    $char init_int
    if viewtk TKind.COLON == {
        %Token+
        if is_static {
            _parse_dollar_static_init
        } else {
            _parse_dollar_non_static_init
        }
    } else {
        0 =init
        false =init_int
    }

    if size 0 < {
        error "Invalid definition for buffer '"eputs name eputs "'\n"eputs
        1 exit
    }
    if size BUFFER_SIZE_LIMIT > {
        error "Buffer '"eputs name eputs "' cannot exceed "eputs BUFFER_SIZE_LIMIT eput " bytes\n"eputs
        1 exit
    }

    nip
    name scope BUF_MAP scoped_map_get
    name over->Buffer.key.name!
    scope over->Buffer.key.scope!
    size over->Buffer.size!
    type_name over->Buffer.type_name!
    init over->Buffer.init!
    init_int over->Buffer.init_int!c
    is_static over->Buffer.is_static!c
    alloc_offset swap->Buffer.alloc_offset!
}

// ops_dest tok_ptr -- new_tok_ptr
:parse_ref {
    %Token+
    // -- ops_dest tok_ptr
    if viewtd FN_MAP scoped_map_find_idx is_success {
        viewtd FN_MAP scoped_map_find_idx OKind.PUSH_FN 3 roll op_push
        %Token+
        return
    }

    // -- ops_dest tok_ptr name idx
    viewtd dup BUF_MAP scoped_map_find_idx
    if dup is_success {
        // -- ops_dest tok_ptr
        nip push_buf_ptr
        nip %Token+
    } else {
        drop
        swap error swap "Buffer '"eputs eputs "' not defined in this scope\n"eputs
        1 exit
    }
}

// ops_dest tok_ptr -- new_tok_ptr
:parse_eq {
    %Token+
    // -- ops_dest tok_ptr name size
    view_buffer_access
    if dup 8 == {
        drop drop
        0 OKind.STORE 3 roll op_push
    } else if dup 1 == {
        drop drop call_storec nip
    } else {
        rot error "Buffer '"eputs rot eputs "' ("eputs swap eput " bytes) cannot be automatically assigned to\n"eputs
        1 exit
    }
}

// ops_dest tok_ptr -- new_tok_ptr
:parse_enum {
    %Token+
    if viewtk TKind.IDENT != {
        error "Invalid enum name\n"eputs
        1 exit
    }
    // -- tok_ptr
    if swap {
        error "Enum '"eputs viewtd eputs "' must be defined in global scope\n"eputs
        1 exit
    }

    $int scope: {if IS_PUBLIC { NULL } else { SCOPE_STACK stack_last@ }}
    $ptr enum_name: {viewtd}
    $ptr variants_ptr: {ENUM_MEM stack_top}
    enum_name scope check_name_availability

    %Token+
    if viewtk TKind.BRACE_START != {
        error "Invalid enum definition\n"eputs
        1 exit
    }

    %Token+
    while viewtk TKind.BRACE_END != {
        if viewtk TKind.IDENT != {
            error "Invalid variant for enum '"eputs enum_name eputs "'\n"eputs
            1 exit
        }

        // -- tok_ptr name variants
        viewtd variants_ptr
        while dup->EnumVariant.name@ {
            if over over->EnumVariant.name@ streq {
                // -- name tok_ptr
                drop swap
                error "Variant '"eputs over eputs "' already defined for enum '"eputs enum_name eputs "'\n"eputs
                1 exit
            }
            %EnumVariant+
        }

        // -- name tok_ptr
        drop swap %Token+
        if viewtk TKind.COLON == {
            %Token+
            if viewtk TKind.INT != {
                error "Invalid value for enum variant '"eputs over eputs "'\n"eputs
                1 exit
            }
            // -- name tok_ptr value
            viewtd
            if ENUM_MEM stack_last->EnumVariant.name@ {
                if dup ENUM_MEM stack_last->EnumVariant.value@ <= {
                    drop
                    error "Enum '"eputs enum_name eputs "' must have values in ascending order\n"eputs
                    1 exit
                }
            }
            swap %Token+ swap
        } else {
            if ENUM_MEM stack_last->EnumVariant.name@ {
                ENUM_MEM stack_last->EnumVariant.value@ 1+
            } else { 0 }
            // -- name tok_ptr value
        }
        // -- tok_ptr value name slot_ptr
        rot ENUM_MEM stack_push
        swap over->EnumVariant.name! ->EnumVariant.value!
    }
    %Token+

    NULL ENUM_MEM stack_push->EnumVariant.name!

    enum_name scope ENUM_MAP scoped_map_get
    enum_name over->Enum.key.name!
    scope over->Enum.key.scope!
    variants_ptr swap->Enum.variants!
}

// ops_dest tok_ptr -- new_tok_ptr
:parse_struct {
    %Token+
    if viewtk TKind.IDENT != {
        error "Invalid struct name\n"eputs
        1 exit
    }
    // -- tok_ptr
    if swap {
        error "Struct '"eputs viewtd eputs "' must be defined in global scope\n"eputs
        1 exit
    }

    $int scope: {if IS_PUBLIC { NULL } else { SCOPE_STACK stack_last@ }}
    $ptr struct_name: {viewtd}
    $ptr fields_ptr: {STRUCT_MEM stack_top}
    struct_name scope check_name_availability

    %Token+
    if viewtk TKind.BRACE_START != {
        error "Invalid struct definition\n"eputs
        1 exit
    }

    %Token+
    while viewtk TKind.BRACE_END != {
        $ptr type_name

        // -- type_name_ptr new_tok_ptr size n_toks
        dup view_buf_size_int over 3 pick - %Token/
        // -- new_tok_ptr size type_name_ptr
        if 3 roll (viewtk TKind.IDENT ==) rot (1 ==) & {
            ->Token.data@ =type_name
        } else {
            drop
            0 =type_name
        }

        // -- new_tok_ptr size
        if over->Token.kind@c TKind.IDENT != {
            drop
            error "Invalid field for struct '"eputs struct_name eputs "'\n"eputs
            1 exit
        }

        // -- tok_ptr size name field
        over->Token.data@ fields_ptr
        while dup->StructField.name@ {
            if over over->StructField.name@ streq {
                // -- name tok_ptr
                drop nip swap
                error "Field '"eputs over eputs "' already defined for struct '"eputs struct_name eputs "'\n"eputs
                1 exit
            }
            %StructField+
        }

        // -- tok_ptr size name slot_ptr
        drop STRUCT_MEM stack_push
        swap over->StructField.name!
        swap over->StructField.size!
        type_name swap->StructField.type_name!
        %Token+
    }
    %Token+
    NULL STRUCT_MEM stack_push->StructField.name!

    struct_name scope STRUCT_MAP scoped_map_get
    struct_name over->Struct.key.name!
    scope over->Struct.key.scope!
    fields_ptr swap->Struct.fields!
}

// ops_dest tok_ptr -- new_tok_ptr
:parse_arrow {
    %Token+
    if viewtk TKind.IDENT != {
        error "Invalid struct name after '->'\n"eputs
        1 exit
    }

    // -- ops_dest new_tok_ptr type_name
    viewtd swap %Token+ swap
    // -- ops_dest new_tok_ptr type_name field_size offset
    while view_field_access {
        // -- ops_dest new_tok_ptr type_name offset
        nip OKind.PUSH_INT 4 pick op_push
        0 OKind.ADD 4 pick op_push
    }

    // -- ops_dest new_tok_ptr offset
    nip nip
    OKind.PUSH_INT 3 pick op_push
    0 OKind.ADD 3 roll op_push
}

// ops_dest tok_ptr -- new_tok_ptr
:parse_size {
    %Token+
    if viewtd STRUCT_MAP scoped_map_find_idx is_success {
        view_type_size
    // -- ops_dest tok_ptr idx
    } else if viewtd BUF_MAP scoped_map_find_idx dup is_success {
        BUF_MAP map_idx
    } else {
        drop
        error "Buffer '"eputs viewtd eputs "' not defined\n"eputs
        1 exit
    }
    OKind.PUSH_INT 3 roll op_push
    %Token+
}

// ops_dest tok_ptr -- new_tok_ptr
:parse_call {
    0 OKind.CALL 3 roll op_push
    %Token+
}

// ops_dest tok_ptr -- new_tok_ptr
:parse_tok {
    if viewtk TKind.PUB == {
        true =IS_PUBLIC
        %Token+
        if viewtk TKind.ENUM == { parse_enum }
        else if viewtk TKind.STRUCT == { parse_struct }
        else {
            error "Unexpected token of type "eputs viewtk eput " after 'pub'\n"eputc
            1 exit
        }
        false =IS_PUBLIC
    }
    else if viewtk TKind.WORD == {
        error "Macro '"eputs viewtd eputs "' not defined\n"eputs
        1 exit
    }
    else if viewtk dup (TKind.INT ==) swap (TKind.CHAR ==) | {
        viewtd OKind.PUSH_INT 3 roll op_push
        %Token+
    }
    else if viewtk TKind.PAREN_START == {
        %Token+
        dup SCOPE_STACK stack_push!
        _parse_until({TKind.PAREN_END})
        &scope_stack stack_shrink
        nip
    }
    else if viewtk TKind.STR == { parse_string }
    else if viewtk TKind.IDENT == { parse_ident }
    else if viewtk TKind.IF == { parse_if }
    else if viewtk TKind.WHILE == { parse_while }
    else if viewtk TKind.FN == { parse_fn }
    else if viewtk TKind.DOLLAR == { parse_dollar }
    else if viewtk TKind.REF == { parse_ref }
    else if viewtk TKind.EQ == { parse_eq }
    else if viewtk TKind.ENUM == { parse_enum }
    else if viewtk TKind.STRUCT == { parse_struct }
    else if viewtk TKind.ARROW == { parse_arrow }
    else if viewtk TKind.SIZE == { parse_size }
    else if viewtk TKind.CALL == { parse_call }
    else if viewtk TKind.FILE_START == {
        dup SCOPE_STACK stack_push!
        nip %Token+
    }
    else if viewtk TKind.FILE_END == {
        &scope_stack stack_shrink
        nip %Token+
    }
    else {
        error "Unexpected token of type "eputs viewtk eput "\n"eputc
        1 exit
    }
}

// kind -- bool
:is_tok_allowed_outside_main {
    $char kind: {}
    (kind TKind.FN ==)
    (kind TKind.DOLLAR ==)
    (kind TKind.ENUM ==)
    (kind TKind.STRUCT ==)
    (kind TKind.PUB ==)
    (kind TKind.FILE_START ==)
    (kind TKind.FILE_END ==)
    | | | | | |
}

:pub parse_out_toks {
    // -- tok_ptr
    &out_toks_mem->StackHead.data
    while viewtk TKind.EOF != {
        if viewtk is_tok_allowed_outside_main not {
            error "Unexpected token of type "eputs viewtk eput " outside of 'main'\n"eputs
            1 exit
        }
        0 swap parse_tok
    }
    drop

    if "main" FN_MAP scoped_map_find_idx is_failure {
        error "Function 'main' not defined\n"eputs
        1 exit
    }
    "main" FN_MAP scoped_map_find_idx OKind.CALL_FN &start_ops_mem op_push
    0 OKind.PUSH_INT &start_ops_mem op_push
    0 OKind.EXIT &start_ops_mem op_push
    0 OKind.EOF &start_ops_mem op_push
}