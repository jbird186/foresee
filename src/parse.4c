#include "std/stdstr.4c"
#include "src/config.4c"
#include "src/token.4c"

$static int ASM_LABEL_ID
$static int ASM_ROLL_ID
$static int ASM_FOPEN_ID

:parse_tok

// ops_dest tok_ptr -- ops_dest tok_ptr
#_parse_until(until_tok_kind) {
    while viewtk until_tok_kind != {
        over swap parse_tok
    }
    tok_next
}

#define_intrinsic_opcode(data op_code alias) {
    if viewtd alias str_eq {
        // -- tok_ptr
        (data) op_code 3 roll toks_push
        tok_next
        return
    }
}

// name -- name [idx, -1]
:scoped_buf_idx {
    $static int scope_idx
    &scope_stack stack_len =scope_idx

    while &scope_idx@-- {
        // -- name idx
        dup scope_idx &scope_stack stack_get bmap_get_idx
        if dup is_success { return }
        drop
    }
    -1
}

// ops_dest tok_ptr -- new_tok_ptr
:parse_string {
    viewtd &inline_bufs stack_push
    // -- tok_ptr
    &inline_bufs stack_len 1- MAP_SIZE+ OP_PUSH_BUF 3 roll toks_push
    tok_next
}

// ops_dest tok_ptr -- new_tok_ptr
:parse_ident {
    ////////// Intrinsics //////////
    // Misc / Special
    define_intrinsic_opcode(0 OP_NOOP "__OP_NOOP")
    define_intrinsic_opcode(0 OP_EXIT "__OP_EXIT")
    // Functions
    define_intrinsic_opcode(0 OP_RET "__OP_RET")
    // Stack Primitives
    define_intrinsic_opcode(0 OP_DROP "__OP_DROP")
    define_intrinsic_opcode(0 OP_PICK "__OP_PICK")
    define_intrinsic_opcode({ASM_ROLL_ID dup 2+ &ASM_ROLL_ID!} OP_ROLL "__OP_ROLL")
    define_intrinsic_opcode(0 OP_DEPTH "__OP_DEPTH")
    // Reference Primitives
    define_intrinsic_opcode(0 OP_STORE "__OP_STORE")
    define_intrinsic_opcode(0 OP_FETCH "__OP_FETCH")
    // Binary Operations
    define_intrinsic_opcode(0 OP_ADD "__OP_ADD")
    define_intrinsic_opcode(0 OP_SUB "__OP_SUB")
    define_intrinsic_opcode(0 OP_MUL "__OP_MUL")
    define_intrinsic_opcode(0 OP_DIV "__OP_DIV")
    define_intrinsic_opcode(0 OP_AND "__OP_AND")
    define_intrinsic_opcode(0 OP_OR "__OP_OR")
    define_intrinsic_opcode(0 OP_XOR "__OP_XOR")
    define_intrinsic_opcode(0 OP_SHL "__OP_SHL")
    define_intrinsic_opcode(0 OP_SHR "__OP_SHR")
    define_intrinsic_opcode(0 OP_SAR "__OP_SAR")
    define_intrinsic_opcode(0 OP_NOT "__OP_NOT")
    define_intrinsic_opcode(0 OP_EQ "__OP_EQ")
    define_intrinsic_opcode(0 OP_GT "__OP_GT")
    define_intrinsic_opcode(0 OP_LT "__OP_LT")
    // I/O
    define_intrinsic_opcode({&ASM_FOPEN_ID@++} OP_FOPEN "__OP_FOPEN")
    define_intrinsic_opcode(0 OP_FREAD "__OP_FREAD")
    define_intrinsic_opcode(0 OP_FWRITE "__OP_FWRITE")
    define_intrinsic_opcode(0 OP_FCLOSE "__OP_FCLOSE")

    ////////// Functions //////////
    // -- ops_dest tok_ptr
    if viewtd &fns_map map_get {
        // -- tok_ptr
        viewtd &fns_map map_key_idx OP_CALL 3 roll toks_push
    // -- ops_dest tok_ptr name idx
    } else if viewtd scoped_buf_idx dup is_success {
        // -- ops_dest tok_ptr name idx
        dup OP_PUSH_BUF 5 pick toks_push
        if dup bmap_idx_size 8 == {
            // -- ops_dest tok_ptr
            drop drop
            0 OP_FETCH 3 roll toks_push
        } else if dup bmap_idx_size 1 == {
            // -- ops_dest tok_ptr
            drop drop
            // -- ops_dest tok_ptr storec_fn_ptr
            if "fetchc" &fns_map map_key_idx dup is_failure {
                "ERROR: Function 'fetchc' not defined\n"eputs
                1 exit
            }
            OP_CALL 3 roll toks_push
        } else {
            "ERROR: Buffer '"eputs over eputs "' cannot be automatically read from\n"eputs
            1 exit
        }
    } else {
        "ERROR: Function '"eputs drop eputs "' not defined\n"eputs
        1 exit
    }
    tok_next
}

// ops_dest tok_ptr if_id -- new_tok_ptr
:_parse_if_with_id {
    // -- ops_dest tok_ptr if_id else_id
    &ASM_LABEL_ID@++
    // -- if_id else_id ops_dest tok_ptr
    3 roll 3 roll
    tok_next
    // Condition
    _parse_until(TOK_BRACE_START)
    // -- if_id else_id ops_dest tok_ptr
    2 pick OP_JZ 3 pick toks_push

    // Operations
    dup &scope_stack stack_push
    _parse_until(TOK_BRACE_END)
    &scope_stack stack_shrink

    // -- if_id else_id ops_dest tok_ptr
    3 pick OP_JMP 3 pick toks_push
    2 pick OP_LABEL 3 pick toks_push
    // -- if_id ops_dest tok_ptr
    rot drop

    // No else condition
    if viewtk TOK_ELSE != {
        swap drop
        // tok_ptr
        swap drop
        return
    }
    tok_next

    // Else condition
    // -- if_id ops_dest tok_ptr
    if viewtk TOK_BRACE_START == {
        tok_next

        dup &scope_stack stack_push
        _parse_until(TOK_BRACE_END)
        &scope_stack stack_shrink

        swap drop
        swap drop
    } else if viewtk TOK_IF == {
        // -- tok_ptr
        rot _parse_if_with_id
    } else {
        "ERROR: Invalid 'if' condition\n"eputs
        1 exit
    }
}

// ops_dest tok_ptr -- new_tok_ptr
:parse_if {
    // -- ops_dest if_id tok_ptr
    &ASM_LABEL_ID@++ swap
    // -- ops_dest if_id tok_ptr
    2 pick swap 2 pick _parse_if_with_id
    // -- tok_ptr
    swap OP_LABEL 3 roll toks_push
}

// ops_dest tok_ptr -- new_tok_ptr
:parse_while {
    tok_next

    // -- ops_dest tok_ptr start_id end_id
    &ASM_LABEL_ID@++ &ASM_LABEL_ID@++
    // -- start_id end_id ops_dest tok_ptr
    3 roll 3 roll
    // -- start_id end_id ops_dest tok_ptr
    3 pick OP_LABEL 3 pick toks_push

    // Condition
    _parse_until(TOK_BRACE_START)
    2 pick OP_JZ 3 pick toks_push

    // Operations
    dup &scope_stack stack_push
    _parse_until(TOK_BRACE_END)
    &scope_stack stack_shrink

    // -- end_id ops_dest tok_ptr
    3 roll OP_JMP 3 pick toks_push
    // -- tok_ptr
    rot OP_LABEL 3 roll toks_push

}

// ops_dest tok_ptr -- new_tok_ptr
:parse_fn {
    if viewtd &fns_map map_get dup (-1 !=) swap (0 !=) & {
        "ERROR: Function '"eputs viewtd eputs "' already defined\n"eputs
        1 exit
    }

    // -- tok_ptr
    if swap {
        "ERROR: Function '"eputs viewtd eputs "' must not define internal functions\n"eputs
        1 exit
    }

    // -- name tok_ptr
    viewtd swap tok_next
    // Function prototype
    if viewtk TOK_BRACE_START != {
        // -- tok_ptr
        swap -1 &fns_map map_insert
        return
    }
    dup &scope_stack stack_push

    // -- name tok_ptr fn_ptr
    &fn_ops_mem toks_top
    // -- tok_ptr
    rot swap &fns_map map_insert
    tok_next

    while viewtk TOK_BRACE_END != {
        &fn_ops_mem swap parse_tok
    }
    tok_next

    if &fn_ops_mem toks_top tok_prev tok_kind OP_RET != {
        0 OP_RET &fn_ops_mem toks_push
    }

    0 OP_EOF &fn_ops_mem toks_push
    &scope_stack stack_shrink
}

:view_buf_size

// base tok_ptr -- total tok_ptr
:view_buf_size_scalar {
    while viewtk TOK_BRACKET_START == {
        // -- total tok_ptr scalar
        tok_next view_buf_size
        // -- total tok_ptr
        rot * swap
        if viewtk TOK_BRACKET_END != {
            "ERROR: Invalid buffer size\n"eputs
            1 exit
        }
        tok_next
    }
}

// tok_ptr -- new_tok_ptr int
:view_buf_size_int {
    if viewtk TOK_INT == {
        // -- base tok_ptr
        viewtd swap tok_next
        view_buf_size_scalar
    } else if viewtk TOK_IDENT == {
        if viewtd &structs_map map_get dup not {
            drop
            "ERROR: '"eputs viewtd eputs "' is not a known type\n"eputs
            1 exit
        }

        // -- tok_ptr sum fields
        0 swap while dup@ {
            8+ dup@ rot + swap
            8+
        }
        // -- sum tok_ptr
        drop swap tok_next
        view_buf_size_scalar
    } else {
        // -- value tok_ptr
        tok_next view_buf_size swap
        if viewtk TOK_BRACKET_END != {
            "ERROR: Invalid buffer size\n"eputs
            1 exit
        }
        tok_next
    }
    // -- tok_ptr value
    swap
    if dup 0 < {
		"ERROR: Invalid buffer size\n"eputs
		1 exit
	}
}

// tok_ptr -- bool
:tok_is_type {
    if viewtk TOK_IDENT != {
        drop false return
    }
    tok_data &structs_map map_get flag
}

// tok_ptr -- new_tok_ptr size
:view_buf_size {
	// -- sum tok_ptr
	0 swap while (viewtk TOK_INT ==) (over tok_is_type) | {
		view_buf_size_int rot + swap
	}
    swap

	if dup 0 < {
		"ERROR: Invalid buffer size\n"eputs
		1 exit
	}
}


// ops_dest tok_ptr -- new_tok_ptr
:parse_dollar {
    // -- tok_ptr
    swap drop

    tok_next
    if viewtk TOK_STATIC != {
        if viewtk TOK_IDENT == {
            "ERROR: Buffer '"eputs viewtd eputs "' must be static\n"eputs
        } else if tok_next viewtk TOK_IDENT == {
            "ERROR: Buffer '"eputs viewtd eputs "' must be static\n"eputs
        } else {
            "ERROR: Invalid buffer name\n"eputs
        }
        1 exit
    }

    tok_next
    $static int size
    if (viewtk TOK_INT ==) (over tok_is_type) | {
        view_buf_size =size
    } else {
        -1 =size
    }

    $static ptr name
    if viewtk TOK_IDENT != {
        "ERROR: Invalid buffer name\n"eputs
        1 exit
    } else if viewtd &scope_stack stack_last bmap_get_idx is_success {
        "ERROR: Buffer '"eputs viewtd eputs "' already defined\n"eputs
        1 exit
    }
    viewtd =name
    tok_next

    $static ptr init
    if viewtk TOK_COLON == {
        tok_next
        if viewtk TOK_STR == {
            // -- tok_ptr str_size
            viewtd str_len 1+
            if size 0 < {
                =size
            } else {
                if size > {
                    "ERROR: Invalid size for buffer '"eputs name eputs "'\n"eputs
                    1 exit
                }
            }
        } else if viewtk TOK_INT == {
            if size 0 < {
                -8 =size
            } else {
                if (size 8 ==) {}
                else if (viewtd dup (0xff <=) swap (0 >=) &) (size 1 ==) & {}
                else {
                    "ERROR: Invalid size for buffer '"eputs name eputs "'\n"eputs
                    1 exit
                }
                // Negative values signal integer initialization
                size -1 * =size
            }
        } else if viewtk TOK_CHAR == {
            if size 0 < {
                -1 =size
            } else {
                if (size 8 !=) (size 1 !=) & {
                    "ERROR: Invalid size for buffer '"eputs name eputs "'\n"eputs
                    1 exit
                }
                // Negative values signal integer initialization
                size -1 * =size
            }
        } else {
            "ERROR: Invalid initialization value for buffer '"eputs name eputs "'\n"eputs
            1 exit
        }
        viewtd =init
        tok_next
    } else {
        0 =init
        if size 0 < {
            "ERROR: Invalid definition for buffer '"eputs name eputs "'\n"eputs
            1 exit
        }
    }

    if size BUFFER_SIZE_LIMIT > {
        "ERROR: Buffer '"eputs name eputs "' too cannot exceed "eputs BUFFER_SIZE_LIMIT eput " bytes\n"eputs
        1 exit
    }

    init size name &scope_stack stack_last bmap_insert
}

// ops_dest tok_ptr -- new_tok_ptr
:parse_ref {
    // -- ops_dest tok_ptr name idx
    viewtd scoped_buf_idx
    if dup is_success {
        // -- tok_ptr name
        OP_PUSH_BUF 4 roll toks_push
        drop tok_next
    } else {
        "ERROR: Buffer '"eputs over eputs "' not defined in this scope\n"eputs
        1 exit
    }
}

// ops_dest tok_ptr -- new_tok_ptr
:parse_eq {
    // -- ops_dest tok_ptr name idx
    viewtd scoped_buf_idx
    if dup is_success {
        // -- ops_dest tok_ptr name idx
        dup OP_PUSH_BUF 5 pick toks_push
        if dup bmap_idx_size 8 == {
            // -- ops_dest tok_ptr
            drop drop
            0 OP_STORE 3 roll toks_push
        } else if dup bmap_idx_size 1 == {
            // -- ops_dest tok_ptr
            drop drop
            // -- ops_dest tok_ptr storec_fn_ptr
            if "storec" &fns_map map_key_idx dup is_failure {
                "ERROR: Function 'storec' not defined\n"eputs
                1 exit
            }
            OP_CALL 3 roll toks_push
        } else {
            "ERROR: Buffer '"eputs over eputs "' cannot be automatically assigned to\n"eputs
            1 exit
        }
        // -- tok_ptr
        tok_next
    } else {
        "ERROR: Buffer '"eputs over eputs "' not defined in this scope\n"eputs
        1 exit
    }
}

// ops_dest tok_ptr -- new_tok_ptr
:parse_struct {
    // -- tok_ptr
    swap drop tok_next
    if viewtk TOK_IDENT != {
        "ERROR: Invalid struct name\n"eputs
        1 exit
    }

    $static ptr name
    viewtd =name
    $static ptr fields_ref
    &struct_fields_mem stack_top =fields_ref

    tok_next
    if viewtk TOK_BRACE_START != {
        "ERROR: Invalid struct definition\n"eputs
        1 exit
    }

    tok_next
    while viewtk TOK_BRACE_END != {
        // -- size tok_ptr
        view_buf_size_int swap
        if viewtk TOK_IDENT != {
            "ERROR: Invalid definition for struct '"eputs name eputs "'\n"eputs
            1 exit
        }
        viewtd &struct_fields_mem stack_push
        // -- tok_ptr
        swap &struct_fields_mem stack_push
        tok_next
    }
    tok_next
    0 &struct_fields_mem stack_push
    name fields_ref &structs_map map_insert
}

// ops_dest tok_ptr -- new_tok_ptr
:parse_arrow {
    tok_next
    if viewtk TOK_IDENT != {
        "ERROR: Invalid struct name after '->'\n"eputs
        1 exit
    }
    $static ptr stuct_name
    viewtd=stuct_name

    // -- ops_dest tok_ptr struct_ptr
    if stuct_name &structs_map map_get dup not {
        drop
        "ERROR: Unrecognized struct '"eputs stuct_name eputs "'\n"eputs
        1 exit
    }

    // -- ops_dest struct_ptr tok_ptr
    swap tok_next
    if viewtk TOK_FIELD != {
        "ERROR: Expected field access after '->"eputs stuct_name eputs "'\n"eputs
        1 exit
    }

    // -- ops_dest tok_ptr field_name struct_ptr
    viewtd rot
    $static int sum
    0=sum
    while dup@ {
        if over over@ str_eq {
            sum OP_PUSH_INT 5 pick toks_push
            // -- tok_ptr field_name struct_ptr
            0 OP_ADD 5 roll toks_push
            drop drop tok_next
            return
        }
        dup 8+ @ sum + =sum
        16+
    }

    drop
    "ERROR: Field '"eputs eputs "' not found for struct '"eputs stuct_name eputs "'\n"eputs
    1 exit
}

#parse_with(parse_kind parse_function) {
    else if viewtk parse_kind == {
        parse_function
    }
}

// ops_dest tok_ptr -- new_tok_ptr
:parse_tok {
    if viewtk TOK_POUND == {
        "ERROR: Unexpected preprocessing directive\n"eputs
        1 exit
    }
    else if viewtk TOK_WORD == {
        "ERROR: Macro '"eputs viewtd eputs "' not defined\n"eputs
        1 exit
    }
    else if viewtk dup (TOK_INT ==) swap (TOK_CHAR ==) | {
        viewtd OP_PUSH_INT 3 roll toks_push
        tok_next
    }
    else if viewtk TOK_PAREN_START == {
        tok_next
        _parse_until(TOK_PAREN_END)
        swap drop
    }
    parse_with(TOK_STR parse_string)
    parse_with(TOK_IDENT parse_ident)
    parse_with(TOK_IF parse_if)
    parse_with(TOK_WHILE parse_while)
    parse_with(TOK_FN parse_fn)
    parse_with(TOK_DOLLAR parse_dollar)
    parse_with(TOK_REF parse_ref)
    parse_with(TOK_EQ parse_eq)
    parse_with(TOK_STRUCT parse_struct)
    parse_with(TOK_ARROW parse_arrow)
    else {
        "ERROR: Unexpected token of type "eputs viewtk eput cr
        1 exit
    }
}

:parse_out_toks {
    $static char kind
    // -- tok_ptr
    &out_toks_mem tok_first
    while viewtk =kind kind TOK_EOF != {
        if (kind TOK_FN !=) (kind TOK_DOLLAR !=) (kind TOK_STRUCT !=) & & {
            "ERROR: Unexpected token of type "eputs viewtk eput " outside of 'main'\n"eputs
            1 exit
        }
        0 swap parse_tok
    }
    drop

    // -- main_fn_ptr
    if "main" &fns_map map_key_idx dup is_failure {
        "ERROR: Function 'main' not defined\n"eputs
        1 exit
    }
    OP_CALL &start_ops_mem toks_push
    0 OP_PUSH_INT &start_ops_mem toks_push
    0 OP_EXIT &start_ops_mem toks_push
    0 OP_EOF &start_ops_mem toks_push
}