#use "stdstr.4c"
#use "config.4c"
#use "platform.4c"
#use "token.4c"
#use "op.4c"

static int ASM_LABEL_ID
static int FN_ALLOC_SIZE
static int CURRENT_ALLOC_SIZE
static int TOTAL_DATA_SIZE

// n --
:alloc_bytes {
    dup +=CURRENT_ALLOC_SIZE
    if CURRENT_ALLOC_SIZE FN_ALLOC_SIZE > {
        CURRENT_ALLOC_SIZE =FN_ALLOC_SIZE
    }

    var int scope: {ALLOC_STACK stack_last}
    scope@ + scope!
}

// tok_ptr -- tok_ptr
:new_local_scope {
    0 ALLOC_STACK stack_push!
    dup SCOPE_STACK stack_push!
}

:pop_local_scope {
    ALLOC_STACK stack_last@ -=CURRENT_ALLOC_SIZE
    &alloc_stack stack_shrink
    &scope_stack stack_shrink
}

:parse_tok

// ops_dest tok_ptr -- ops_dest tok_ptr
// Does *not* parse the until_tok_kind token
#macro parse_until(until_tok_kind) {(
    var &Token original_tok_ptr: {dup}
    while viewtk until_tok_kind != {
        if viewtk not {
            original_tok_ptr error
            "Expected token of type "puts until_tok_kind put
            " after token of type "puts viewtk put
            "\n"puts
            1 exit
        }
        over swap parse_tok
    }
    %Token+
)}

// tok_ptr -- bool
:tok_is_simple_type {
    if viewtk TKind.REF == { %Token+ }
    if viewtk TKind.IDENT != {
        drop false return
    }
    as Token.data@ STRUCT_MAP scoped_map_find_idx is_success
}

// ops_dest tok_ptr idx -- ops_dest tok_ptr
:push_buf_ptr {
    var int idx: {}
    var &Buffer entry: {idx BUF_MAP map_idx}
    if entry->is_static {
        idx OKind.PUSH_BUF 3 pick op_push
    } else {
        entry->alloc_offset entry->size +
        OKind.PUSH_VAR 3 pick op_push
    }
}

// tok_ptr name scope -- tok_ptr
:check_name_availability_fn {
    var int scope: {}
    var &char name: {}
    if name "__OP_" 5 strncmp not {
        %Token- error "Item cannot overwrite intrinsic opcode\n"puts
        1 exit
    }
    if name scope BUF_MAP scoped_map_get slot_is_used {
        error "Buffer '"puts name puts "' already defined in this scope\n"puts
        1 exit
    }
    if name scope STRUCT_MAP scoped_map_get slot_is_used {
        error "Struct '"puts name puts "' already defined in this scope\n"puts
        1 exit
    }
    if name scope ENUM_MAP scoped_map_get slot_is_used {
        error "Enum '"puts name puts "' already defined in this scope\n"puts
        1 exit
    }
}

// tok_ptr name scope -- tok_ptr
:check_name_availability {
    if over over FN_MAP scoped_map_get slot_is_used {
        error "Function '"puts over puts "' already defined in this scope\n"puts
        1 exit
    }
    check_name_availability_fn
}

// ops_dest tok_ptr struct_name -- ops_dest new_tok_ptr type_name should_chain field_size
:view_field_access {
    // -- ops_dest tok_ptr
    var &char struct_name: {}
    if struct_name STRUCT_MAP scoped_map_find_idx is_failure {
        error "Unrecognized struct '"puts struct_name puts "'\n"puts
        1 exit
    }

    var &StructField fields_ptr: {
        struct_name STRUCT_MAP scoped_map_find as Struct.fields@
    }

    if viewtk TKind.DEREF == {
        while viewtk TKind.DEREF == {
            0 OKind.FETCH 3 pick op_push
            %Token+
        }
    } else if viewtk TKind.FIELD == {
        %Token+
    } else {
        error "Expected field access into '"puts struct_name puts "'\n"puts
        1 exit
    }

    var &char field_name: {viewtd}
    var int field_offset: 0
    while fields_ptr->name {
        var int field_size: {fields_ptr->size}
        if field_name fields_ptr->name strcmp not {
            %Token+

            field_offset OKind.PUSH_INT 3 pick op_push
            0 OKind.ADD 3 pick op_push

            var &int dims: {fields_ptr->type.dims}
            while viewtk TKind.BRACKET_START == {
                %Token+
                parse_until(TKind.BRACKET_END)

                if (if dims {dims@ not} else {true}) {
                    error
                    "Field '"puts fields_ptr->name puts
                    "' of struct '"puts struct_name puts
                    "' cannot be indexed to this depth\n"puts
                    1 exit
                }
                dims@ /=field_size
                %ptr +=dims

                field_size OKind.PUSH_INT 3 pick op_push
                0 OKind.MUL 3 pick op_push
                0 OKind.ADD 3 pick op_push
            }

            fields_ptr->type.name
            over as Token.kind@c dup (TKind.FIELD ==) swap (TKind.DEREF ==) |
            field_size
            return
        }
        field_size +=field_offset
        %StructField +=fields_ptr
    }

    error "Field '"puts field_name puts "' not found for struct '"puts struct_name puts "'\n"puts
    1 exit
}

// ops_dest tok_ptr -- ops_dest new_tok_ptr size
:view_buffer_access {
    var &char name: {viewtd}
    var int idx: {name BUF_MAP scoped_map_find_idx}
    if idx is_failure {
        error "Buffer '"puts name puts "' not defined in this scope\n"puts
        1 exit
    }

    %Token+
    var &Buffer buf: {idx BUF_MAP map_idx}
    var int size: {buf->size}
    idx push_buf_ptr

    if viewtk dup (TKind.FIELD ==) swap (TKind.DEREF ==) | {
        // -- ops_dest new_tok_ptr type_name
        buf->type.name
        while view_field_access =size {}
        drop
    }

    while viewtk TKind.BRACKET_START == {
        if (buf->type.name not) {
            error "Buffer '"puts name puts "' cannot be indexed to this depth\n"puts
            1 exit
        }

        var &int dims: {buf->type.dims}
        while viewtk TKind.BRACKET_START == {
            %Token+
            parse_until(TKind.BRACKET_END)

            if (if dims {dims@ not} else {true}) {
                error "Buffer '"puts name puts "' cannot be indexed to this depth\n"puts
                1 exit
            }
            dims@ /=size
            %ptr +=dims

            size OKind.PUSH_INT 3 pick op_push
            0 OKind.MUL 3 pick op_push
            0 OKind.ADD 3 pick op_push
        }

        if viewtk dup (TKind.FIELD ==) swap (TKind.DEREF ==) | {
            // -- ops_dest new_tok_ptr type_name
            buf->type.name
            while view_field_access =size {}
            drop
        }
    }

    size
}

// ops_dest name --
:call_fn_injected {
    var &char name: {}
    var int idx: { name FN_MAP scoped_map_find_idx }
    if idx is_failure {
        "ERROR: Function '"puts name puts "' not defined\n"puts
        1 exit
    }
    true idx FN_MAP map_idx as Function.is_used!c
    idx OKind.CALL_FN rot op_push
}

// ops_dest tok_ptr -- new_tok_ptr
:parse_string {
    var int idx: { viewtd INLINE_STR_MAP map_get_idx }
    var &InlineStr s: { idx INLINE_STR_MAP map_idx }
    if s slot_is_empty {
        viewtd =s->value
    }
    (idx MAP_SIZE+) OKind.PUSH_BUF 3 roll op_push
    %Token+
}

// ops_dest tok_ptr -- new_tok_ptr
:parse_buffer_ident {
    var &char name: {viewtd}
    var int size: {view_buffer_access}
    if size 8 == {
        0 OKind.FETCH 3 roll op_push
    } else if size 1 == {
        0 OKind.FETCHC 3 roll op_push
    } else {
        error "Buffer '"puts name puts "' ("puts size put " bytes) cannot be automatically read from\n"puts
        1 exit
    }
}

// tok_ptr -- new_tok_ptr int
:_view_enum_as_int {
    var int enum_name: {viewtd}
    var &EnumVariant variant: {
        enum_name ENUM_MAP scoped_map_find as Enum.variants@
    }

    %Token+
    if viewtk TKind.FIELD != {
        error "Expected variant after '"puts enum_name puts "'\n"puts
        1 exit
    }
    %Token+
    if viewtk TKind.IDENT != {
        error "Expected variant after '"puts enum_name puts ".'\n"puts
        1 exit
    }
    var int variant_name: {viewtd}

    while variant->name {
        if variant_name variant->name strcmp not {
            %Token+
            variant->value return
        }
        %EnumVariant +=variant
    }

    error "Variant '"puts variant_name puts "' not found for enum '"puts enum_name puts "'\n"puts
    1 exit
}

// ops_dest tok_ptr -- new_tok_ptr
:parse_ident {
    ////////// Intrinsics //////////
    #macro define_intrinsic_opcode(data, op_code, alias) {
        if viewtd alias strcmp not {
            // -- tok_ptr
            (data) op_code 3 roll op_push
            %Token+
            return
        }
    }

    // Misc / Special
    define_intrinsic_opcode(0, OKind.NOOP, "__OP_NOOP")
    // Functions
    define_intrinsic_opcode(0, OKind.RET, "__OP_RET")
    // Stack Primitives
    define_intrinsic_opcode(0, OKind.DROP, "__OP_DROP")
    define_intrinsic_opcode(0, OKind.PICK, "__OP_PICK")
    define_intrinsic_opcode(&ASM_LABEL_ID@++, OKind.ROLL, "__OP_ROLL")
    define_intrinsic_opcode(0, OKind.DUP, "__OP_DUP")
    define_intrinsic_opcode(0, OKind.OVER, "__OP_OVER")
    define_intrinsic_opcode(0, OKind.SWAP, "__OP_SWAP")
    define_intrinsic_opcode(0, OKind.ROT, "__OP_ROT")
    define_intrinsic_opcode(0, OKind.NIP, "__OP_NIP")
    define_intrinsic_opcode(0, OKind.DEPTH, "__OP_DEPTH")
    // Reference Primitives
    define_intrinsic_opcode(0, OKind.STORE, "__OP_STORE")
    define_intrinsic_opcode(0, OKind.FETCH, "__OP_FETCH")
    define_intrinsic_opcode(0, OKind.STOREC, "__OP_STOREC")
    define_intrinsic_opcode(0, OKind.FETCHC, "__OP_FETCHC")
    define_intrinsic_opcode(&ASM_LABEL_ID@++, OKind.MEMCPY, "__OP_MEMCPY")
    // Binary Operations
    define_intrinsic_opcode(0, OKind.ADD, "__OP_ADD")
    define_intrinsic_opcode(0, OKind.SUB, "__OP_SUB")
    define_intrinsic_opcode(0, OKind.MUL, "__OP_MUL")
    define_intrinsic_opcode(0, OKind.AND, "__OP_AND")
    define_intrinsic_opcode(0, OKind.OR, "__OP_OR")
    define_intrinsic_opcode(0, OKind.XOR, "__OP_XOR")
    define_intrinsic_opcode(0, OKind.SHL, "__OP_SHL")
    define_intrinsic_opcode(0, OKind.SHR, "__OP_SHR")
    define_intrinsic_opcode(0, OKind.SAR, "__OP_SAR")
    define_intrinsic_opcode(0, OKind.NOT, "__OP_NOT")
    define_intrinsic_opcode(0, OKind.DIVMOD, "__OP_DIVMOD")
    // Comparison
    define_intrinsic_opcode(0, OKind.EQ, "__OP_EQ")
    define_intrinsic_opcode(0, OKind.NE, "__OP_NE")
    define_intrinsic_opcode(0, OKind.GE, "__OP_GE")
    define_intrinsic_opcode(0, OKind.GT, "__OP_GT")
    define_intrinsic_opcode(0, OKind.LE, "__OP_LE")
    define_intrinsic_opcode(0, OKind.LT, "__OP_LT")
    // Syscalls
    define_intrinsic_opcode(0, OKind.EXIT, "__OP_EXIT")
    define_intrinsic_opcode(&ASM_LABEL_ID@++, OKind.FOPEN, "__OP_FOPEN")
    define_intrinsic_opcode(&ASM_LABEL_ID@++, OKind.FREAD, "__OP_FREAD")
    define_intrinsic_opcode(&ASM_LABEL_ID@++, OKind.FWRITE, "__OP_FWRITE")
    define_intrinsic_opcode(0, OKind.FCLOSE, "__OP_FCLOSE")
    define_intrinsic_opcode(&ASM_LABEL_ID@++, OKind.GETCWD, "__OP_GETCWD")
    // Linux Only
    define_intrinsic_opcode(0, OKind.LIN_syscall, "__LIN_syscall")
    // Windows Only
    define_intrinsic_opcode(0, OKind.WIN_GetCommandLineW, "__WIN_GetCommandLineW")
    define_intrinsic_opcode(&ASM_LABEL_ID@++, OKind.WIN_CommandLineToArgvW, "__WIN_CommandLineToArgvW")
    define_intrinsic_opcode(&ASM_LABEL_ID@++, OKind.WIN_WideCharToMultiByte, "__WIN_WideCharToMultiByte")
    define_intrinsic_opcode(&ASM_LABEL_ID@++, OKind.WIN_LocalAlloc, "__WIN_LocalAlloc")
    define_intrinsic_opcode(0, OKind.WIN_LocalFree, "__WIN_LocalFree")
    define_intrinsic_opcode(0, OKind.WIN_GetStdHandle, "__WIN_GetStdHandle")

    ////////// Functions //////////
    var int fn_idx: { viewtd FN_MAP scoped_map_find_idx }
    if fn_idx is_success {
        fn_idx OKind.CALL_FN 3 roll op_push
        %Token+
        return
    }

    ////////// Enums //////////
    if viewtd ENUM_MAP scoped_map_find_idx is_success {
        _view_enum_as_int OKind.PUSH_INT 3 roll op_push
        return
    }

    ////////// Buffers //////////
    parse_buffer_ident
}

// ops_dest tok_ptr if_id -- new_tok_ptr
:_parse_if_with_id {
    // -- ops_dest tok_ptr if_id else_id
    &ASM_LABEL_ID@++
    // -- if_id else_id ops_dest tok_ptr
    3 roll 3 roll
    %Token+
    // Condition
    new_local_scope
    parse_until(TKind.BRACE_START)
    pop_local_scope
    // -- if_id else_id ops_dest tok_ptr
    2 pick OKind.JZ 3 pick op_push

    // Operations
    new_local_scope
    parse_until(TKind.BRACE_END)
    pop_local_scope

    // -- if_id else_id ops_dest tok_ptr
    3 pick OKind.JMP 3 pick op_push
    2 pick OKind.LABEL 3 pick op_push
    // -- if_id ops_dest tok_ptr
    rot drop

    // No else condition
    if viewtk TKind.ELSE != {
        // tok_ptr
        nip nip
        return
    }
    %Token+

    // Else condition
    // -- if_id ops_dest tok_ptr
    if viewtk TKind.BRACE_START == {
        %Token+
        new_local_scope
        parse_until(TKind.BRACE_END)
        pop_local_scope
        nip nip
    } else if viewtk TKind.IF == {
        // -- tok_ptr
        rot _parse_if_with_id
    } else {
        error "Invalid 'if' condition\n"puts
        1 exit
    }
}

// ops_dest tok_ptr -- new_tok_ptr
:parse_if {
    // -- ops_dest if_id tok_ptr
    &ASM_LABEL_ID@++ swap
    // -- ops_dest if_id tok_ptr
    2 pick swap 2 pick _parse_if_with_id
    // -- tok_ptr
    swap OKind.LABEL 3 roll op_push
}

// ops_dest tok_ptr &cases n_cases switch_id id_offset -- ops_dest new_tok_ptr
:_parse_switch_tree {
    var int id_offset: {}
    var int switch_id: {}
    var int n_cases: {}
    var &SwitchCase cases: {}

    // default case
    if n_cases not {
        switch_id 1+ OKind.JMP 3 pick op_push
        return
    }

    var int mid: {n_cases 2/}
    var &SwitchCase switch_case: {cases mid %SwitchCase* +}

    switch_case@ OKind.CMP 3 pick op_push
    if n_cases 1 > {
        var int gt_n_cases: {n_cases mid- 1-}

        var int l_label: {ASM_LABEL_ID}
        if mid { 1+=ASM_LABEL_ID l_label } else { switch_id 1+ }
            OKind.JCMPL 3 pick op_push

        var int g_label: {ASM_LABEL_ID}
        if gt_n_cases { 1+=ASM_LABEL_ID g_label } else { switch_id 1+ }
            OKind.JCMPG 3 pick op_push

        if switch_case->is_merged { 2 switch_case->def+ } else { id_offset mid+ }
            switch_id+ OKind.JMP 3 pick op_push

        // less than case
        if mid {
            l_label OKind.LABEL 3 pick op_push
            cases mid switch_id id_offset _parse_switch_tree
        }

        // greater than case
        if gt_n_cases {
            g_label OKind.LABEL 3 pick op_push
            (switch_case %SwitchCase+) gt_n_cases switch_id (id_offset mid+ 1+) _parse_switch_tree
        }
    } else {
        switch_id 1+ OKind.JCMPNE 3 pick op_push
        if switch_case->is_merged { 2 switch_case->def+ } else { id_offset mid+ }
            switch_id+ OKind.JMP 3 pick op_push
    }
}

// &arr low high --
:_sort_switch_tree {
    var int { high: {} low: {} }
    var &SwitchCase arr: {}
    var SwitchCase temp

    if low high < {
        var &SwitchCase pivot: {arr high %SwitchCase* +}
        var int i: {low 1-}

        for (var int j: {low}, j high <, 1 +=j) {
            var &SwitchCase arr_j: {arr j %SwitchCase* +}
            if arr_j->value pivot->value <= {
                1 +=i
                var &SwitchCase arr_i: {arr i %SwitchCase* +}
                arr_j &temp %SwitchCase memcpy
                arr_i arr_j %SwitchCase memcpy
                &temp arr_i %SwitchCase memcpy
            }
        }
        var &SwitchCase arr_i: {arr i 1+ %SwitchCase* +}
        pivot &temp %SwitchCase memcpy
        arr_i pivot %SwitchCase memcpy
        &temp arr_i %SwitchCase memcpy

        arr low i _sort_switch_tree
        arr i 2+ high _sort_switch_tree
    }
}

// &cases n_cases value -- idx
:_binary_search_known_switch_case {
    var int value: {}
    var int low: 0
    var int high: {1-}
    var &SwitchCase cases: {}

    while low high <= {
        var int mid: {low ((high low -) 2 /) +}
        var &SwitchCase mid_case: { cases mid %SwitchCase* + }
        if mid_case->value value == {
            mid return
        }
        if mid_case->value value < {
            mid 1+ =low
        } else {
            mid 1- =high
        }
    }
}

// ops_dest tok_ptr -- new_tok_ptr
:parse_switch {
    var SwitchCase[MAX_SWITCH_CASES] cases
    var &Token default_case: NULL
    var int switch_id: {ASM_LABEL_ID}
    var int n_cases: 0

    %Token+
    parse_until(TKind.BRACE_START)
    0 OKind.PRE_CMP 3 pick op_push

    var &Token original_tok_ptr: {dup}
    while viewtk TKind.BRACE_END != {
        if viewtk TKind.DEFAULT == {
            %Token+
            if default_case {
                error "'default' case already defined\n"puts
                1 exit
            }
            if viewtk TKind.BRACE_START != {
                error "Expected braces for 'default' block\n"puts
                1 exit
            }
            dup %Token+ =default_case
            skip_braces
            continue
        }

        if viewtk TKind.CASE != {
            error "Expected 'case' block\n"puts
            1 exit
        }
        %Token+

        var int label_id: { n_cases }
        while true {
            switch viewtk {
                case TKind.INT, TKind.CHAR {
                    viewod =cases[n_cases].value
                    %Token+
                }
                case TKind.IDENT {
                    if viewtd ENUM_MAP scoped_map_find_idx is_failure {
                        error "Expected literal integer, literal char, or enum variant for 'case' condition\n" puts
                        1 exit
                    }
                    _view_enum_as_int =cases[n_cases].value
                }
                default {
                    error "Invalid 'case' condition\n"puts
                    1 exit
                }
            }

            cases[label_id].value =cases[n_cases].def
            true =cases[n_cases].is_merged
            1 +=n_cases

            if viewtk TKind.COMMA != { break }
            %Token+
        }
        if viewtk TKind.BRACE_START != {
            error "Expected braces for 'case' block\n"puts
            1 exit
        }

        dup %Token+ =cases[label_id].def
        false =cases[label_id].is_merged
        skip_braces
    }
    %Token+

    &cases 0 n_cases 1- _sort_switch_tree

    for (var int i: 0, i n_cases <, 1 +=i) {
        if cases[i].is_merged {
            &cases n_cases cases[i].def _binary_search_known_switch_case
            =cases[i].def
        }
    }

    n_cases 2+ +=ASM_LABEL_ID
    &cases n_cases switch_id 2 _parse_switch_tree

    if default_case {
        switch_id 1+ OKind.LABEL 3 pick op_push
        swap default_case new_local_scope
        parse_until(TKind.BRACE_END) drop swap
        switch_id OKind.JMP 3 pick op_push
        pop_local_scope
    }

    var int prev: 0
    for (var int i: 0, i n_cases <, 1 +=i) {
        if i {
            if prev cases[i].value == {
                cases[ if cases[i].is_merged {cases[i].def} else {i} ].def
                error "Duplicate 'case' condition for "puts cases[i].value put "\n"puts
                1 exit
            }
        }

        if cases[i].is_merged not {
            switch_id 2+ i+ OKind.LABEL 3 pick op_push
            swap cases[i].def new_local_scope
            parse_until(TKind.BRACE_END) drop swap
            switch_id OKind.JMP 3 pick op_push
            pop_local_scope
        }

        cases[i].value =prev
    }
    if default_case not {
        switch_id 1+ OKind.LABEL 3 pick op_push
    }
    switch_id OKind.LABEL 3 roll op_push
}

// ops_dest tok_ptr -- new_tok_ptr
:parse_while {
    %Token+
    var int label_id: {ASM_LABEL_ID}
    2 +=ASM_LABEL_ID

    label_id LOOP_STACK stack_push!
    new_local_scope

    label_id OKind.LABEL 3 pick op_push

    // Condition
    parse_until(TKind.BRACE_START)
    label_id 1+ OKind.JZ 3 pick op_push

    // Operations
    parse_until(TKind.BRACE_END)

    &loop_stack stack_shrink
    pop_local_scope

    label_id OKind.JMP 3 pick op_push
    label_id 1+ OKind.LABEL 3 roll op_push
}

// ops_dest tok_ptr -- new_tok_ptr
:parse_for {
    %Token+
    var int label_id: {ASM_LABEL_ID}
    3 +=ASM_LABEL_ID

    var char has_paren: {false}
    if viewtk TKind.PAREN_START == {
        dup skip_paren
        if viewtk dup (TKind.COMMA !=) swap (TKind.BRACE_START !=) & {
            drop error "Invalid 'for' loop\n"puts
            1 exit
        }
        as Token.kind@c TKind.BRACE_START == =has_paren
    }
    if has_paren { %Token+ }

    label_id LOOP_STACK stack_push!
    new_local_scope

    // Initialization
    parse_until(TKind.COMMA)

    label_id 2+ OKind.LABEL 3 pick op_push

    // Condition
    parse_until(TKind.COMMA)
    var &Token iter: {dup}
    if has_paren { skip_until(TKind.PAREN_END) %Token+ }
    else { skip_until(TKind.BRACE_START) }
    label_id 1+ OKind.JZ 3 pick op_push

    // Operations
    parse_until(TKind.BRACE_END)

    label_id OKind.LABEL 3 pick op_push

    // Iteration
    swap iter
    if has_paren { parse_until(TKind.PAREN_END) }
    else { parse_until(TKind.BRACE_START) }
    drop swap

    &loop_stack stack_shrink
    pop_local_scope

    label_id 2+ OKind.JMP 3 pick op_push
    label_id 1+ OKind.LABEL 3 roll op_push
}

// ops_dest tok_ptr -- new_tok_ptr
:parse_continue {
    if &loop_stack stack_len not {
        error "'continue' can only be used within loops\n"puts
        1 exit
    }
    LOOP_STACK stack_last@ OKind.JMP 3 roll op_push
    %Token+
}

// ops_dest tok_ptr -- new_tok_ptr
:parse_break {
    if &loop_stack stack_len not {
        error "'break' can only be used within loops\n"puts
        1 exit
    }
    LOOP_STACK stack_last@ 1+ OKind.JMP 3 roll op_push
    %Token+
}

// ops_dest tok_ptr -- new_tok_ptr
:parse_fn {
    %Token+
    if viewtk TKind.IDENT != {
        error "Invalid function name\n"puts
        1 exit
    }
    // -- tok_ptr
    if swap {
        error "Function '"puts viewtd puts "' must be defined in global scope\n"puts
        1 exit
    }

    var int scope: {if IS_PUBLIC { NULL } else { SCOPE_STACK stack_last@ }}
    var &char name: {viewtd}
    %Token+

    name scope check_name_availability_fn

    var &Function entry: {name scope FN_MAP scoped_map_get}
    name =entry->key.name
    scope =entry->key.scope
    false =entry->is_used
    viewtf =entry->file

    // Function prototype
    if viewtk TKind.BRACE_START != {
        NULL =entry->def
        return
    }

    var &Op fn_ptr: {&fn_ops_mem %Op stack_top}
    fn_ptr =entry->def
    %Token+

    0 =ASM_LABEL_ID
    0 =FN_ALLOC_SIZE
    0 =CURRENT_ALLOC_SIZE
    0 OKind.ALLOC &fn_ops_mem op_push
    new_local_scope

    while viewtk TKind.BRACE_END != {
        &fn_ops_mem swap parse_tok
    }
    %Token+

    if &fn_ops_mem %Op stack_last as Token.kind@c OKind.RET != {
        0 OKind.RET &fn_ops_mem op_push
    }

    // Align to 16 bytes for Windows calling convention
    if "OS_WINDOWS" has_builtin_flag {
        16 (FN_ALLOC_SIZE 8+ 16%)- 16% +=FN_ALLOC_SIZE
    }

    // fn_ops tok_ptr
    pop_local_scope
    if FN_ALLOC_SIZE {
        FN_ALLOC_SIZE =fn_ptr->data
    } else {
        OKind.NOOP =fn_ptr->kind
    }
    0 OKind.EOF &fn_ops_mem op_push
}

// tok_ptr -- tok_ptr size
:view_type_size {
    if viewtd STRUCT_MAP scoped_map_find dup slot_is_empty {
        drop
        error "Type '"puts viewtd puts "' not found\n"puts
        1 exit
    }
    as Struct.size@
}

// tok_ptr -- new_tok_ptr name indir dims size
:view_simple_type {
    var int indir: 0
    if viewtk TKind.REF == {
        viewtd =indir
        %Token+
    }

    if viewtk TKind.IDENT != {
        error "Invalid type\n"puts
        1 exit
    }
    var &char type_name: {viewtd}
    var int total_size: {if indir { 8 } else { view_type_size }}
    %Token+

    var &int dims: 0
    if viewtk TKind.BRACKET_START == {
        DIMS_MEM stack_top =dims
        while viewtk TKind.BRACKET_START == {
            var int subtotal: 0

            if %Token+ viewtk TKind.INT != {
                error "Invalid array size\n"puts
                1 exit
            }
            while viewtk TKind.INT == {
                viewtd +=subtotal
                %Token+
            }
            if viewtk TKind.BRACKET_END != {
                error "Invalid buffer size\n"puts
                1 exit
            }
            %Token+

            subtotal DIMS_MEM stack_push!
            subtotal *=total_size
        }
        0 DIMS_MEM stack_push!
    }
    type_name indir dims total_size
}

// tok_ptr -- new_tok_ptr size
:view_complex_subtype {
    if %Token+ viewtk TKind.BRACKET_END == {
        error "Invalid array size\n"puts
        1 exit
    }

    var int total: 0
    while viewtk TKind.BRACKET_END != {
        if viewtk TKind.INT != {
            error "Invalid buffer size\n"puts
            1 exit
        }
        var int subtotal: {viewtd}
        %Token+

        while viewtk TKind.BRACKET_START == {
            view_complex_subtype *=subtotal
        }
        subtotal +=total
    }
    %Token+

    total
}

// tok_ptr -- new_tok_ptr size
:view_complex_type {
    if %Token+ viewtk TKind.BRACKET_END == {
        error "Invalid array size\n"puts
        1 exit
    }

    var int total: 0
    while viewtk TKind.BRACKET_END != {
        var int subtotal
        if viewtk TKind.INT == {
            viewtd =subtotal
        } else if viewtk TKind.IDENT == {
            view_type_size =subtotal
        } else if viewtk TKind.REF == {
            8 =subtotal
            if %Token+ viewtk TKind.IDENT != {
                error "Invalid pointer type\n"puts
                1 exit
            }
        } else {
            error "Invalid buffer size\n"puts
            1 exit
        }
        %Token+

        while viewtk TKind.BRACKET_START == {
            view_complex_subtype *=subtotal
        }
        subtotal +=total
    }
    %Token+

    total
}

#macro _parse_buffer_non_static_init {
    if (size 1 ==) (size 8 ==) | not {
        error "Buffer '"puts name puts "' ("puts size put " bytes) cannot be automatically assigned to\n"puts
        1 exit
    }

    if viewtk TKind.INT == {
        if size 1 == {
            if viewtd dup (0xff <=) swap (0 >=) & not {
                error "Invalid size for buffer '"puts name puts "'\n"puts
                1 exit
            }
        }
        viewtd OKind.PUSH_INT 3 pick op_push
        %Token+
    } else if viewtk TKind.CHAR == {
        viewtd OKind.PUSH_INT 3 pick op_push
        %Token+
    } else if viewtk TKind.BRACE_START == {
        %Token+
        new_local_scope
        parse_until(TKind.BRACE_END)
        pop_local_scope
    } else {
        error "Non-static buffers can only utilize block initialization\n"puts
        1 exit
    }

    alloc_offset size+ OKind.PUSH_VAR 3 pick op_push
    if size 1 == {
        0 OKind.STOREC 3 pick op_push
    } else {
        0 OKind.STORE 3 pick op_push
    }
}

#macro _parse_buffer_static_init {
    if viewtk TKind.STR == {
        // -- tok_ptr str_size
        viewtd strlen 1+
        if size 0 < {
            =size
        } else if size > {
            error "Invalid size for buffer '"puts name puts "'\n"puts
            1 exit
        }
        false =init_int
    } else if viewtk TKind.INT == {
        if size 0 < {
            8 =size
        } else {
            if size 8 == {}
            else if (viewtd dup (0xff <=) swap (0 >=) &) (size 1 ==) & {}
            else {
                error "Invalid size for buffer '"puts name puts "'\n"puts
                1 exit
            }
        }
        true =init_int
    } else if viewtk TKind.CHAR == {
        if size 0 < {
            1 =size
        } else {
            if (size 8 !=) (size 1 !=) & {
                error "Invalid size for buffer '"puts name puts "'\n"puts
                1 exit
            }
        }
        true =init_int
    } else {
        error "Invalid initialization value for buffer '"puts name puts "'\n"puts
        1 exit
    }
    viewtd =init
    %Token+
}

#macro _parse_next_buffer {
    if viewtk TKind.IDENT != {
        error "Invalid buffer name\n"puts
        1 exit
    }

    var int alloc_offset
    if is_static {
        0 =alloc_offset
    } else {
        CURRENT_ALLOC_SIZE =alloc_offset
        size alloc_bytes
    }

    var &char name: {viewtd}
    name scope check_name_availability

    %Token+
    var [8] init
    var bool init_int
    if viewtk TKind.COLON == {
        %Token+
        if is_static {
            _parse_buffer_static_init
        } else {
            _parse_buffer_non_static_init
        }
    } else {
        0 =init
        false =init_int
    }

    if size 0 < {
        error "Invalid size for buffer '"puts name puts "'\n"puts
        1 exit
    }
    if size BUFFER_SIZE_LIMIT > {
        error "Buffer '"puts name puts "' cannot exceed "puts BUFFER_SIZE_LIMIT put " bytes\n"puts
        1 exit
    }
    size +=TOTAL_DATA_SIZE
    if size DATA_SIZE_LIMIT > {
        error "Total data usage cannot exceed "puts DATA_SIZE_LIMIT put " bytes\n"puts
        1 exit
    }

    var &Buffer entry: {name scope BUF_MAP scoped_map_get}
    name =entry->key.name
    scope =entry->key.scope
    size =entry->size
    type_name =entry->type.name
    type_dims =entry->type.dims
    type_indir =entry->type.indir
    alloc_offset =entry->alloc_offset
    init =entry->init
    init_int =entry->init_int
    is_static =entry->is_static
}

// ops_dest tok_ptr -- new_tok_ptr
:parse_buffer_def {
    var int scope: {if IS_PUBLIC { NULL } else { SCOPE_STACK stack_last@ }}
    var char is_static
    if viewtk TKind.STATIC == {
        true =is_static
    } else if over {
        false =is_static
    } else {
        error "Buffers defined at global scope must be static\n"puts
        1 exit
    }
    %Token+

    var int size
    var int type_indir: 0
    var &char type_name: NULL
    var &int type_dims: NULL
    if dup tok_is_simple_type {
        view_simple_type =size =type_dims =type_indir =type_name
    } else if viewtk TKind.BRACKET_START == {
        view_complex_type =size
    } else {
        -1 =size
    }

    if viewtk TKind.BRACE_START == {
        %Token+
        while viewtk TKind.BRACE_END != {
            _parse_next_buffer
        }
        %Token+
    } else {
        _parse_next_buffer
    }
    nip
}

// ops_dest tok_ptr -- new_tok_ptr
:parse_ref {
    if viewtd 1 != {
        error "Invalid reference depth of "puts viewtd put "\n"puts
        1 exit
    }

    %Token+
    var int fn_idx: { viewtd FN_MAP scoped_map_find_idx }
    if fn_idx is_success {
        fn_idx OKind.PUSH_FN 3 roll op_push
        %Token+
        return
    }

    view_buffer_access drop nip
}

// ops_dest tok_ptr -- new_tok_ptr
:parse_eq {
    var &Token original_tok_ptr: {dup}
    if viewtd "=" strcmp {
        %Token+
        over swap parse_buffer_ident
        drop original_tok_ptr

        #macro parse_simple_eq(string, opcode, preop) {
            else if viewtd string strcmp not {
                preop
                0 opcode 3 pick op_push
            }
        }
        if viewtd "/=" strcmp not {
            0 OKind.SWAP 3 pick op_push
            0 OKind.DIVMOD 3 pick op_push
            0 OKind.DROP 3 pick op_push
        }
        else if viewtd "%=" strcmp not {
            0 OKind.SWAP 3 pick op_push
            0 OKind.DIVMOD 3 pick op_push
            0 OKind.NIP 3 pick op_push
        }
        parse_simple_eq("+=", OKind.ADD,)
        parse_simple_eq("-=", OKind.SUB, 0 OKind.SWAP 3 pick op_push)
        parse_simple_eq("*=", OKind.MUL,)
        parse_simple_eq("&=", OKind.AND,)
        parse_simple_eq("|=", OKind.OR,)
        parse_simple_eq("^=", OKind.XOR,)
        parse_simple_eq("<<=", OKind.SHL, 0 OKind.SWAP 3 pick op_push)
        parse_simple_eq("<<<=", OKind.SHL, 0 OKind.SWAP 3 pick op_push)
        parse_simple_eq(">>=", OKind.SHR, 0 OKind.SWAP 3 pick op_push)
        parse_simple_eq(">>>=", OKind.SAR, 0 OKind.SWAP 3 pick op_push)
        else {
            error "Unknown assignment operator '"puts viewtd puts "'\n"puts
            1 exit
        }
    }

    %Token+
    var &char name: {viewtd}
    var int size: {view_buffer_access}
    if size 8 == {
        0 OKind.STORE 3 roll op_push
    } else if size 1 == {
        0 OKind.STOREC 3 roll op_push
    } else {
        error "Buffer '"puts name puts "' ("puts size put " bytes) cannot be automatically assigned to\n"puts
        1 exit
    }
}

// ops_dest tok_ptr -- new_tok_ptr
:parse_enum {
    %Token+
    if viewtk TKind.IDENT != {
        error "Invalid enum name\n"puts
        1 exit
    }
    // -- tok_ptr
    if swap {
        error "Enum '"puts viewtd puts "' must be defined in global scope\n"puts
        1 exit
    }

    var int scope: {if IS_PUBLIC { NULL } else { SCOPE_STACK stack_last@ }}
    var &char enum_name: {viewtd}
    var &EnumVariant variants_ptr: {ENUM_MEM stack_top}
    enum_name scope check_name_availability

    %Token+
    if viewtk TKind.BRACE_START != {
        error "Invalid enum definition\n"puts
        1 exit
    }

    %Token+
    while viewtk TKind.BRACE_END != {
        if viewtk TKind.IDENT != {
            error "Invalid variant for enum '"puts enum_name puts "'\n"puts
            1 exit
        }

        // -- tok_ptr name variants
        viewtd variants_ptr
        while dup as EnumVariant.name@ {
            if over over as EnumVariant.name@ strcmp not {
                // -- name tok_ptr
                drop swap
                error "Variant '"puts over puts "' already defined for enum '"puts enum_name puts "'\n"puts
                1 exit
            }
            %EnumVariant+
        }

        // -- name tok_ptr
        drop swap %Token+
        if viewtk TKind.COLON == {
            %Token+
            if viewtk TKind.INT != {
                error "Invalid value for enum variant '"puts over puts "'\n"puts
                1 exit
            }
            // -- name tok_ptr value
            viewtd
            if ENUM_MEM stack_last as EnumVariant.name@ {
                if dup ENUM_MEM stack_last as EnumVariant.value@ <= {
                    drop
                    error "Enum '"puts enum_name puts "' must have values in ascending order\n"puts
                    1 exit
                }
            }
            swap %Token+ swap
        } else {
            if ENUM_MEM stack_last as EnumVariant.name@ {
                ENUM_MEM stack_last as EnumVariant.value@ 1+
            } else { 0 }
            // -- name tok_ptr value
        }
        // -- tok_ptr value name slot_ptr
        rot ENUM_MEM stack_push
        swap over as EnumVariant.name!  as EnumVariant.value!
    }
    %Token+

    NULL ENUM_MEM stack_push as EnumVariant.name!

    var &Enum entry: {enum_name scope ENUM_MAP scoped_map_get}
    enum_name =entry->key.name
    scope =entry->key.scope
    variants_ptr =entry->variants
}

// ops_dest tok_ptr -- new_tok_ptr
:parse_struct {
    %Token+
    if viewtk TKind.IDENT != {
        error "Invalid struct name\n"puts
        1 exit
    }
    // -- tok_ptr
    if swap {
        error "Struct '"puts viewtd puts "' must be defined in global scope\n"puts
        1 exit
    }

    var int scope: {if IS_PUBLIC { NULL } else { SCOPE_STACK stack_last@ }}
    var &char struct_name: {viewtd}
    var &StructField fields_ptr: {STRUCT_MEM stack_top}
    struct_name scope check_name_availability

    %Token+
    if viewtk TKind.BRACE_START != {
        error "Invalid struct definition\n"puts
        1 exit
    }

    %Token+
    var int struct_size: 0
    while viewtk TKind.BRACE_END != {
        var int size
        var int type_indir: 0
        var &char type_name: NULL
        var int type_dims: NULL
        if dup tok_is_simple_type {
            view_simple_type =size =type_dims =type_indir =type_name
        } else if viewtk TKind.BRACKET_START == {
            view_complex_type =size
        } else {
            error "Invalid field type\n"puts
            1 exit
        }

        // -- tok_ptr size
        size
        if over as Token.kind@c TKind.IDENT != {
            drop
            error "Invalid field for struct '"puts struct_name puts "'\n"puts
            1 exit
        }

        // -- tok_ptr size name field
        over as Token.data@ fields_ptr
        while dup as StructField.name@ {
            if over over as StructField.name@ strcmp not {
                // -- name tok_ptr
                drop nip swap
                error "Field '"puts over puts "' already defined for struct '"puts struct_name puts "'\n"puts
                1 exit
            }
            %StructField+
        }
        2 pick +=struct_size
        drop

        // -- tok_ptr size name
        var &StructField entry: {STRUCT_MEM stack_push}
        =entry->name
        =entry->size
        type_name =entry->type.name
        type_dims =entry->type.dims
        type_indir =entry->type.indir
        %Token+
    }
    %Token+
    NULL STRUCT_MEM stack_push as StructField.name!

    var &Struct entry: {struct_name scope STRUCT_MAP scoped_map_get}
    struct_name =entry->key.name
    scope =entry->key.scope
    struct_size =entry->size
    fields_ptr =entry->fields
}

// ops_dest tok_ptr -- new_tok_ptr
:parse_as {
    %Token+
    if viewtk TKind.IDENT != {
        error "Invalid struct name after 'as'\n"puts
        1 exit
    }

    // -- ops_dest new_tok_ptr type_name
    viewtd swap %Token+ swap
    while view_field_access drop {}
    drop nip
}

// ops_dest tok_ptr -- new_tok_ptr
:parse_size {
    %Token+
    if viewtd STRUCT_MAP scoped_map_find_idx is_success {
        view_type_size
    // -- ops_dest tok_ptr idx
    } else if viewtd BUF_MAP scoped_map_find_idx dup is_success {
        BUF_MAP map_idx as Buffer.size@
    } else {
        drop
        error "Buffer '"puts viewtd puts "' not defined\n"puts
        1 exit
    }
    OKind.PUSH_INT 3 roll op_push
    %Token+
}

// ops_dest tok_ptr -- new_tok_ptr
:parse_call {
    0 OKind.CALL 3 roll op_push
    %Token+
}

// ops_dest tok_ptr -- new_tok_ptr
:parse_tok {
    false =IS_PUBLIC
    switch viewtk {
        case TKind.PUB {
            if over {
                error "Public items must be defined at global scope\n"puts
                1 exit
            }

            true =IS_PUBLIC
            %Token+
            switch viewtk {
                case TKind.FN { parse_fn }
                case TKind.STATIC { parse_buffer_def }
                case TKind.VAR { parse_buffer_def }
                case TKind.ENUM { parse_enum }
                case TKind.STRUCT { parse_struct }
                default {
                    error "Unexpected token of type "puts viewtk put " after 'pub'\n"puts
                    1 exit
                }
            }
        }
        case TKind.WORD {
            error "Macro '"puts viewtd puts "' not defined\n"puts
            1 exit
        }
        case TKind.INT, TKind.CHAR {
            viewtd OKind.PUSH_INT 3 roll op_push
            %Token+
        }
        case TKind.PAREN_START {
            %Token+
            new_local_scope
            parse_until(TKind.PAREN_END)
            pop_local_scope
            nip
        }
        case TKind.STR { parse_string }
        case TKind.IDENT { parse_ident }
        case TKind.IF { parse_if }
        case TKind.SWITCH { parse_switch }
        case TKind.WHILE { parse_while }
        case TKind.FOR { parse_for }
        case TKind.CONTINUE { parse_continue }
        case TKind.BREAK { parse_break }
        case TKind.FN { parse_fn }
        case TKind.STATIC { parse_buffer_def }
        case TKind.VAR { parse_buffer_def }
        case TKind.REF { parse_ref }
        case TKind.EQ { parse_eq }
        case TKind.ENUM { parse_enum }
        case TKind.STRUCT { parse_struct }
        case TKind.AS { parse_as }
        case TKind.SIZE { parse_size }
        case TKind.CALL { parse_call }
        case TKind.FILE_START {
            dup SCOPE_STACK stack_push!
            nip %Token+
        }
        case TKind.FILE_END {
            &scope_stack stack_shrink
            nip %Token+
        }
        default {
            error "Unexpected token of type "puts viewtk put "\n"puts
            1 exit
        }
    }
}

// kind -- bool
:is_tok_allowed_outside_main {
    switch {
        case TKind.FN,
            TKind.STATIC,
            TKind.ENUM,
            TKind.STRUCT,
            TKind.PUB,
            TKind.FILE_START,
            TKind.FILE_END
            { true }
        default { false }
    }
}

pub :parse_out_toks {
    // -- tok_ptr
    &out_toks_mem as StackHead.data
    while viewtk TKind.EOF != {
        if viewtk is_tok_allowed_outside_main not {
            error "Unexpected token of type "puts viewtk put " outside of 'main'\n"puts
            1 exit
        }
        0 swap parse_tok
    }
    drop

    if "OS_WINDOWS" has_builtin_flag {
        &start_ops_mem "__parse_args" call_fn_injected
    }
    &start_ops_mem "main" call_fn_injected

    if "OS_WINDOWS" has_builtin_flag {
        8 OKind.ALLOC &start_ops_mem op_push
    }
    0 OKind.PUSH_INT &start_ops_mem op_push
    0 OKind.EXIT &start_ops_mem op_push
    0 OKind.EOF &start_ops_mem op_push
}