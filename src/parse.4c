#use "stdstr.4c"
#use "config.4c"
#use "platform.4c"
#use "token.4c"
#use "op.4c"

static int ASM_LABEL_ID
static int FN_ALLOC_SIZE
static int CURRENT_ALLOC_SIZE
static int TOTAL_DATA_SIZE

:reset_fn_alloc {
    0 =FN_ALLOC_SIZE
    0 =CURRENT_ALLOC_SIZE
}

// n --
:alloc_bytes {
    dup +=CURRENT_ALLOC_SIZE
    if CURRENT_ALLOC_SIZE FN_ALLOC_SIZE > {
        CURRENT_ALLOC_SIZE =FN_ALLOC_SIZE
    }

    $ptr scope: {ALLOC_STACK stack_last}
    scope@ + scope!
}

// tok_ptr -- tok_ptr
:new_local_scope {
    0 ALLOC_STACK stack_push!
    dup SCOPE_STACK stack_push!
}

:pop_local_scope {
    ALLOC_STACK stack_last@ -=CURRENT_ALLOC_SIZE
    &alloc_stack stack_shrink
    &scope_stack stack_shrink
}

:parse_tok

// ops_dest tok_ptr -- ops_dest tok_ptr
#macro parse_until(until_tok_kind) {(
    $ptr original_tok_ptr: {dup}
    while viewtk until_tok_kind != {
        if viewtk not {
            original_tok_ptr error
            "Expected token of type "puts until_tok_kind put
            " after token of type "puts viewtk put
            "\n"puts
            1 exit
        }
        over swap parse_tok
    }
    %Token+
)}

// tok_ptr -- bool
:tok_is_type {
    if viewtk TKind.IDENT != {
        drop false return
    }
    ->Token.data@ STRUCT_MAP scoped_map_find_idx is_success
}

// ops_dest tok_ptr idx -- ops_dest tok_ptr
:push_buf_ptr {
    if dup BUF_MAP map_idx->Buffer.is_static@c {
        OKind.PUSH_BUF 3 pick op_push
    } else {
        BUF_MAP map_idx
        dup->Buffer.alloc_offset@
        swap->Buffer.size@ +
        OKind.PUSH_VAR 3 pick op_push
    }
}

// name scope --
:check_name_availability_fn {
    $ptr scope: {}
    $ptr name: {}
    if name scope BUF_MAP scoped_map_get slot_is_used {
        error "Buffer '"puts name puts "' already defined in this scope\n"puts
        1 exit
    }
    if name scope STRUCT_MAP scoped_map_get slot_is_used {
        error "Struct '"puts name puts "' already defined in this scope\n"puts
        1 exit
    }
    if name scope ENUM_MAP scoped_map_get slot_is_used {
        error "Enum '"puts name puts "' already defined in this scope\n"puts
        1 exit
    }
}

// name scope --
:check_name_availability {
    if over over FN_MAP scoped_map_get slot_is_used {
        error "Function '"puts over puts "' already defined in this scope\n"puts
        1 exit
    }
    check_name_availability_fn
}

// ops_dest tok_ptr struct_name -- ops_dest new_tok_ptr type_name should_chain field_size
:view_field_access {
    // -- ops_dest tok_ptr
    $ptr struct_name: {}
    if struct_name STRUCT_MAP scoped_map_find_idx is_failure {
        error "Unrecognized struct '"puts struct_name puts "'\n"puts
        1 exit
    }

    $ptr fields_ptr: {struct_name STRUCT_MAP scoped_map_find->Struct.fields@}
    if viewtk TKind.FIELD != {
        error "Expected field access after '->"puts struct_name puts "'\n"puts
        1 exit
    }
    %Token+

    $ptr field_name: {viewtd}
    $int field_offset: {0}
    while fields_ptr->StructField.name@ {
        $int field_size: {fields_ptr->StructField.size@}
        if field_name fields_ptr->StructField.name@ strcmp not {
            %Token+

            field_offset OKind.PUSH_INT 3 pick op_push
            0 OKind.ADD 3 pick op_push

            $ptr dims: {fields_ptr->StructField.type.dims@}
            while viewtk TKind.BRACKET_START == {
                %Token+
                parse_until(TKind.BRACKET_END)

                if (if dims {dims@ not} else {true}) {
                    error
                    "Field '"puts fields_ptr->StructField.name@ puts
                    "' of struct '"puts struct_name puts
                    "' cannot be indexed to this depth\n"puts
                    1 exit
                }
                dims@ /=field_size
                %ptr +=dims

                field_size OKind.PUSH_INT 3 pick op_push
                0 OKind.MUL 3 pick op_push
                0 OKind.ADD 3 pick op_push
            }

            fields_ptr->StructField.type.name@
            over->Token.kind@c TKind.FIELD ==
            field_size
            return
        }
        field_size +=field_offset
        %StructField +=fields_ptr
    }

    error "Field '"puts field_name puts "' not found for struct '"puts struct_name puts "'\n"puts
    1 exit
}

// ops_dest tok_ptr -- ops_dest new_tok_ptr size
:view_buffer_access {
    $ptr name: {viewtd}
    $int idx: {name BUF_MAP scoped_map_find_idx}
    if idx is_failure {
        error "Buffer '"puts name puts "' not defined in this scope\n"puts
        1 exit
    }

    %Token+
    $int size: {idx BUF_MAP map_idx->Buffer.size@}
    idx push_buf_ptr

    if viewtk TKind.FIELD == {
        // -- ops_dest new_tok_ptr type_name
        idx BUF_MAP map_idx->Buffer.type.name@
        while view_field_access =size {}
        drop
    }

    while viewtk TKind.BRACKET_START == {
        if (idx BUF_MAP map_idx->Buffer.type.name@ not) {
            error "Buffer '"puts name puts "' cannot be indexed to this depth\n"puts
            1 exit
        }

        $ptr dims: {idx BUF_MAP map_idx->Buffer.type.dims@}
        while viewtk TKind.BRACKET_START == {
            %Token+
            parse_until(TKind.BRACKET_END)

            if (if dims {dims@ not} else {false}) {
                error "Buffer '"puts name puts "' cannot be indexed to this depth\n"puts
                1 exit
            }
            dims@ /=size
            %ptr +=dims

            size OKind.PUSH_INT 3 pick op_push
            0 OKind.MUL 3 pick op_push
            0 OKind.ADD 3 pick op_push
        }

        if viewtk TKind.FIELD == {
            // -- ops_dest new_tok_ptr type_name
            idx BUF_MAP map_idx->Buffer.type.name@
            while view_field_access =size {}
            drop
        }
    }

    size
}

// ops_dest tok_ptr name -- ops_dest tok_ptr
:call_fn {
    if dup FN_MAP scoped_map_find_idx is_failure {
        swap error swap "Function '"puts puts "' not defined\n"puts
        1 exit
    }
    FN_MAP scoped_map_find_idx OKind.CALL_FN 3 pick op_push
}

// ops_dest tok_ptr -- new_tok_ptr
:parse_string {
    viewtd &inline_bufs %ptr stack_push!
    // -- tok_ptr
    &inline_bufs stack_len 1- MAP_SIZE+ OKind.PUSH_BUF 3 roll op_push
    %Token+
}

// ops_dest tok_ptr -- new_tok_ptr
:parse_buffer_ident {
    $ptr name: {viewtd}
    $ptr size: {view_buffer_access}
    if size 8 == {
        0 OKind.FETCH 3 roll op_push
    } else if size 1 == {
        "fetchc" call_fn nip
    } else {
        error "Buffer '"puts name puts "' ("puts size put " bytes) cannot be automatically read from\n"puts
        1 exit
    }
}

// ops_dest tok_ptr -- new_tok_ptr
:parse_ident {
    ////////// Intrinsics //////////
    #macro define_intrinsic_opcode(data, op_code, alias) {
        if viewtd alias strcmp not {
            // -- tok_ptr
            (data) op_code 3 roll op_push
            %Token+
            return
        }
    }

    // Misc / Special
    define_intrinsic_opcode(0, OKind.NOOP, "__OP_NOOP")
    // Functions
    define_intrinsic_opcode(0, OKind.RET, "__OP_RET")
    // Stack Primitives
    define_intrinsic_opcode(0, OKind.DROP, "__OP_DROP")
    define_intrinsic_opcode(0, OKind.PICK, "__OP_PICK")
    define_intrinsic_opcode(&ASM_LABEL_ID@++, OKind.ROLL, "__OP_ROLL")
    define_intrinsic_opcode(0, OKind.DEPTH, "__OP_DEPTH")
    // Reference Primitives
    define_intrinsic_opcode(0, OKind.STORE, "__OP_STORE")
    define_intrinsic_opcode(0, OKind.FETCH, "__OP_FETCH")
    define_intrinsic_opcode(&ASM_LABEL_ID@++, OKind.MEMCPY, "__OP_MEMCPY")
    // Binary Operations
    define_intrinsic_opcode(0, OKind.ADD, "__OP_ADD")
    define_intrinsic_opcode(0, OKind.SUB, "__OP_SUB")
    define_intrinsic_opcode(0, OKind.MUL, "__OP_MUL")
    define_intrinsic_opcode(0, OKind.AND, "__OP_AND")
    define_intrinsic_opcode(0, OKind.OR, "__OP_OR")
    define_intrinsic_opcode(0, OKind.XOR, "__OP_XOR")
    define_intrinsic_opcode(0, OKind.SHL, "__OP_SHL")
    define_intrinsic_opcode(0, OKind.SHR, "__OP_SHR")
    define_intrinsic_opcode(0, OKind.SAR, "__OP_SAR")
    define_intrinsic_opcode(0, OKind.NOT, "__OP_NOT")
    define_intrinsic_opcode(0, OKind.EQ, "__OP_EQ")
    define_intrinsic_opcode(0, OKind.GT, "__OP_GT")
    define_intrinsic_opcode(0, OKind.LT, "__OP_LT")
    define_intrinsic_opcode(0, OKind.DIVMOD, "__OP_DIVMOD")
    // Syscalls
    define_intrinsic_opcode(0, OKind.EXIT, "__OP_EXIT")
    define_intrinsic_opcode(&ASM_LABEL_ID@++, OKind.FOPEN, "__OP_FOPEN")
    define_intrinsic_opcode(&ASM_LABEL_ID@++, OKind.FREAD, "__OP_FREAD")
    define_intrinsic_opcode(&ASM_LABEL_ID@++, OKind.FWRITE, "__OP_FWRITE")
    define_intrinsic_opcode(0, OKind.FCLOSE, "__OP_FCLOSE")
    define_intrinsic_opcode(&ASM_LABEL_ID@++, OKind.GETCWD, "__OP_GETCWD")
    // Linux Only
    define_intrinsic_opcode(0, OKind.LIN_syscall, "__LIN_syscall")
    // Windows Only
    define_intrinsic_opcode(0, OKind.WIN_GetCommandLineW, "__WIN_GetCommandLineW")
    define_intrinsic_opcode(&ASM_LABEL_ID@++, OKind.WIN_CommandLineToArgvW, "__WIN_CommandLineToArgvW")
    define_intrinsic_opcode(&ASM_LABEL_ID@++, OKind.WIN_WideCharToMultiByte, "__WIN_WideCharToMultiByte")
    define_intrinsic_opcode(&ASM_LABEL_ID@++, OKind.WIN_LocalAlloc, "__WIN_LocalAlloc")
    define_intrinsic_opcode(0, OKind.WIN_LocalFree, "__WIN_LocalFree")
    define_intrinsic_opcode(0, OKind.WIN_GetStdHandle, "__WIN_GetStdHandle")

    ////////// Functions //////////
    if viewtd FN_MAP scoped_map_find_idx is_success {
        viewtd FN_MAP scoped_map_find_idx OKind.CALL_FN 3 roll op_push
        %Token+
        return
    }

    ////////// Enums //////////
    if viewtd ENUM_MAP scoped_map_find_idx is_success {
        $int name: {viewtd}

        // -- ops_dest tok_ptr variants
        name ENUM_MAP scoped_map_find->Enum.variants@
        // -- ops_dest variants tok_ptr
        swap %Token+
        if viewtk TKind.FIELD != {
            error "Expected variant after '"puts name puts "'\n"puts
            1 exit
        }
        %Token+
        // -- ops_dest tok_ptr name variants
        viewtd rot
        while dup->EnumVariant.name@ {
            if over over->EnumVariant.name@ strcmp not {
                nip->EnumVariant.value@ OKind.PUSH_INT 3 roll op_push
                %Token+
                return
            }
            %EnumVariant+
        }
        drop
        swap error swap "Variant '"puts puts "' not found for enum '"puts name puts "'\n"puts
        1 exit
    }

    ////////// Buffers //////////
    parse_buffer_ident
}

// ops_dest tok_ptr if_id -- new_tok_ptr
:_parse_if_with_id {
    // -- ops_dest tok_ptr if_id else_id
    &ASM_LABEL_ID@++
    // -- if_id else_id ops_dest tok_ptr
    3 roll 3 roll
    %Token+
    // Condition
    new_local_scope
    parse_until(TKind.BRACE_START)
    pop_local_scope
    // -- if_id else_id ops_dest tok_ptr
    2 pick OKind.JZ 3 pick op_push

    // Operations
    new_local_scope
    parse_until(TKind.BRACE_END)
    pop_local_scope

    // -- if_id else_id ops_dest tok_ptr
    3 pick OKind.JMP 3 pick op_push
    2 pick OKind.LABEL 3 pick op_push
    // -- if_id ops_dest tok_ptr
    rot drop

    // No else condition
    if viewtk TKind.ELSE != {
        // tok_ptr
        nip nip
        return
    }
    %Token+

    // Else condition
    // -- if_id ops_dest tok_ptr
    if viewtk TKind.BRACE_START == {
        %Token+
        new_local_scope
        parse_until(TKind.BRACE_END)
        pop_local_scope
        nip nip
    } else if viewtk TKind.IF == {
        // -- tok_ptr
        rot _parse_if_with_id
    } else {
        error "Invalid 'if' condition\n"puts
        1 exit
    }
}

// ops_dest tok_ptr -- new_tok_ptr
:parse_if {
    // -- ops_dest if_id tok_ptr
    &ASM_LABEL_ID@++ swap
    // -- ops_dest if_id tok_ptr
    2 pick swap 2 pick _parse_if_with_id
    // -- tok_ptr
    swap OKind.LABEL 3 roll op_push
}

// ops_dest tok_ptr -- new_tok_ptr
:parse_while {
    %Token+
    $int label_id: {ASM_LABEL_ID}
    2 +=ASM_LABEL_ID

    label_id OKind.LABEL 3 pick op_push

    label_id LOOP_STACK stack_push!
    new_local_scope

    // Condition
    parse_until(TKind.BRACE_START)
    label_id 1+ OKind.JZ 3 pick op_push

    // Operations
    parse_until(TKind.BRACE_END)

    &loop_stack stack_shrink
    pop_local_scope

    label_id OKind.JMP 3 pick op_push
    label_id 1+ OKind.LABEL 3 roll op_push
}

// ops_dest tok_ptr -- new_tok_ptr
:parse_for {
    %Token+
    $int label_id: {ASM_LABEL_ID}
    3 +=ASM_LABEL_ID

    $char has_paren: {false}
    if viewtk TKind.PAREN_START == {
        dup skip_paren
        if viewtk dup (TKind.COMMA !=) swap (TKind.BRACE_START !=) & {
            drop error "Invalid 'for' loop\n"puts
            1 exit
        }
        ->Token.kind@c TKind.BRACE_START == =has_paren
    }
    if has_paren { %Token+ }

    label_id 2+ LOOP_STACK stack_push!
    new_local_scope

    // Initialization
    parse_until(TKind.COMMA)
    label_id OKind.LABEL 3 pick op_push

    // Condition
    parse_until(TKind.COMMA)
    $ptr iter: {dup}
    if has_paren { skip_until(TKind.PAREN_END) %Token+ }
    else { skip_until(TKind.BRACE_START) }
    label_id 1+ OKind.JZ 3 pick op_push

    // Operations
    parse_until(TKind.BRACE_END)

    label_id 2+ OKind.LABEL 3 pick op_push

    // Iteration
    swap iter
    if has_paren { parse_until(TKind.PAREN_END) }
    else { parse_until(TKind.BRACE_START) }
    drop swap

    &loop_stack stack_shrink
    pop_local_scope

    label_id OKind.JMP 3 pick op_push
    label_id 1+ OKind.LABEL 3 roll op_push
}

// ops_dest tok_ptr -- new_tok_ptr
:parse_continue {
    if &loop_stack stack_len not {
        error "'continue' can only be used within loops\n"puts
        1 exit
    }
    LOOP_STACK stack_last@ OKind.JMP 3 roll op_push
    %Token+
}

// ops_dest tok_ptr -- new_tok_ptr
:parse_break {
    if &loop_stack stack_len not {
        error "'break' can only be used within loops\n"puts
        1 exit
    }
    LOOP_STACK stack_last@ 1+ OKind.JMP 3 roll op_push
    %Token+
}

// ops_dest tok_ptr -- new_tok_ptr
:parse_fn {
    %Token+
    if viewtk TKind.IDENT != {
        error "Invalid function name\n"puts
        1 exit
    }
    // -- tok_ptr
    if swap {
        error "Function '"puts viewtd puts "' must be defined in global scope\n"puts
        1 exit
    }

    $int scope: {if IS_PUBLIC { NULL } else { SCOPE_STACK stack_last@ }}
    $ptr name: {viewtd}
    %Token+

    name scope check_name_availability_fn
    if name scope FN_MAP scoped_map_get->Function.def@ {
        error "Function '"puts name puts "' already defined in this scope\n"puts
        1 exit
    }

    // Function prototype
    if viewtk TKind.BRACE_START != {
        name scope FN_MAP scoped_map_get
        name over->Function.key.name!
        scope swap->Function.key.scope!
        return
    }

    $ptr fn_ptr: {&fn_ops_mem %Op stack_top}
    name scope FN_MAP scoped_map_get
    name over->Function.key.name!
    scope over->Function.key.scope!
    fn_ptr swap->Function.def!
    %Token+

    reset_fn_alloc
    0 OKind.ALLOC &fn_ops_mem op_push
    new_local_scope

    while viewtk TKind.BRACE_END != {
        &fn_ops_mem swap parse_tok
    }
    %Token+

    if &fn_ops_mem %Op stack_last->Token.kind@c OKind.RET != {
        0 OKind.RET &fn_ops_mem op_push
    }

    // Align to 16 bytes for Windows calling convention
    if "OS_WINDOWS" has_builtin_flag {
        16 (FN_ALLOC_SIZE 8+ 16%)- 16% +=FN_ALLOC_SIZE
    }

    // fn_ops tok_ptr
    pop_local_scope
    if FN_ALLOC_SIZE {
        FN_ALLOC_SIZE fn_ptr->Op.data!
    } else {
        OKind.NOOP fn_ptr->Op.kind!c
    }
    0 OKind.EOF &fn_ops_mem op_push
}

// tok_ptr -- tok_ptr size
:view_type_size {
    if viewtk TKind.IDENT != {
        error "Invalid type\n"puts
        1 exit
    }
    if viewtd STRUCT_MAP scoped_map_find dup slot_is_empty {
        drop
        error "Type '"puts viewtd puts "' not found\n"puts
        1 exit
    }
    ->Struct.size@
}

// tok_ptr -- new_tok_ptr name dims size
:view_simple_type {
    $ptr type_name: {viewtd}
    $ptr dims: {0}
    $int total: {view_type_size}
    %Token+
    if viewtk TKind.BRACKET_START == {
        DIMS_MEM stack_top =dims
        while viewtk TKind.BRACKET_START == {
            $int subtotal: {0}

            if %Token+ viewtk TKind.INT != {
                error "Invalid array size\n"puts
                1 exit
            }
            while viewtk TKind.INT == {
                viewtd +=subtotal
                %Token+
            }
            if viewtk TKind.BRACKET_END != {
                error "Invalid buffer size\n"puts
                1 exit
            }
            %Token+

            subtotal DIMS_MEM stack_push!
            subtotal *=total
        }
        0 DIMS_MEM stack_push!
    }
    type_name dims total
}

// tok_ptr -- new_tok_ptr size
:view_complex_subtype {
    if %Token+ viewtk TKind.BRACKET_END == {
        error "Invalid array size\n"puts
        1 exit
    }

    $int total: {0}
    while viewtk TKind.BRACKET_END != {
        if viewtk TKind.INT != {
            error "Invalid buffer size\n"puts
            1 exit
        }
        $int subtotal: {viewtd}
        %Token+

        while viewtk TKind.BRACKET_START == {
            view_complex_subtype *=subtotal
        }
        subtotal +=total
    }
    %Token+

    total
}

// tok_ptr -- new_tok_ptr size
:view_complex_type {
    if %Token+ viewtk TKind.BRACKET_END == {
        error "Invalid array size\n"puts
        1 exit
    }

    $int total: {0}
    while viewtk TKind.BRACKET_END != {
        $int subtotal
        if viewtk TKind.INT == {
            viewtd =subtotal
        } else if viewtk TKind.IDENT == {
            view_type_size =subtotal
        } else {
            error "Invalid buffer size\n"puts
            1 exit
        }
        %Token+

        while viewtk TKind.BRACKET_START == {
            view_complex_subtype *=subtotal
        }
        subtotal +=total
    }
    %Token+

    total
}

#macro _parse_buffer_non_static_init {
    if viewtk TKind.BRACE_START == {
        %Token+
        if (size 1 ==) (size 8 ==) | not {
            error "Buffer '"puts name puts "' ("puts size put " bytes) cannot be automatically assigned to\n"puts
            1 exit
        }

        new_local_scope
        parse_until(TKind.BRACE_END)
        pop_local_scope

        alloc_offset size+ OKind.PUSH_VAR 3 pick op_push
        if size 1 == {
            "storec" call_fn
        } else {
            0 OKind.STORE 3 pick op_push
        }
    } else {
        error "Non-static buffers can only utilize block initialization\n"puts
        1 exit
    }
}

#macro _parse_buffer_static_init {
    if viewtk TKind.STR == {
        // -- tok_ptr str_size
        viewtd strlen 1+
        if size 0 < {
            =size
        } else if size > {
            error "Invalid size for buffer '"puts name puts "'\n"puts
            1 exit
        }
        false =init_int
    } else if viewtk TKind.INT == {
        if size 0 < {
            8 =size
        } else {
            if size 8 == {}
            else if (viewtd dup (0xff <=) swap (0 >=) &) (size 1 ==) & {}
            else {
                error "Invalid size for buffer '"puts name puts "'\n"puts
                1 exit
            }
        }
        true =init_int
    } else if viewtk TKind.CHAR == {
        if size 0 < {
            1 =size
        } else {
            if (size 8 !=) (size 1 !=) & {
                error "Invalid size for buffer '"puts name puts "'\n"puts
                1 exit
            }
        }
        true =init_int
    } else {
        error "Invalid initialization value for buffer '"puts name puts "'\n"puts
        1 exit
    }
    viewtd =init
    %Token+
}

// ops_dest tok_ptr -- new_tok_ptr
:parse_buffer_def {
    $int scope: {if IS_PUBLIC { NULL } else { SCOPE_STACK stack_last@ }}
    $char is_static
    $int alloc_offset
    if viewtk TKind.STATIC == {
        true =is_static
        0 =alloc_offset
    } else if over {
        false =is_static
        CURRENT_ALLOC_SIZE =alloc_offset
    } else {
        error "Buffers defined at global scope must be static\n"puts
        1 exit
    }
    %Token+

    $int size
    $ptr type_name: {NULL}
    $ptr type_dims: {NULL}
    if dup tok_is_type {
        view_simple_type =size =type_dims =type_name
    } else if viewtk TKind.BRACKET_START == {
        view_complex_type =size
    } else {
        -1 =size
    }

    if is_static not {
        size alloc_bytes
    }

    if viewtk TKind.IDENT != {
        error "Invalid buffer name\n"puts
        1 exit
    }
    $ptr name: {viewtd}
    name scope check_name_availability

    %Token+
    $ptr init
    $char init_int
    if viewtk TKind.COLON == {
        %Token+
        if is_static {
            _parse_buffer_static_init
        } else {
            _parse_buffer_non_static_init
        }
    } else {
        0 =init
        false =init_int
    }

    if size 0 < {
        error "Invalid size for buffer '"puts name puts "'\n"puts
        1 exit
    }
    if size BUFFER_SIZE_LIMIT > {
        error "Buffer '"puts name puts "' cannot exceed "puts BUFFER_SIZE_LIMIT put " bytes\n"puts
        1 exit
    }
    size +=TOTAL_DATA_SIZE
    if size DATA_SIZE_LIMIT > {
        error "Total data usage cannot exceed "puts DATA_SIZE_LIMIT put " bytes\n"puts
        1 exit
    }

    nip
    name scope BUF_MAP scoped_map_get
    name over->Buffer.key.name!
    scope over->Buffer.key.scope!
    size over->Buffer.size!
    type_name over->Buffer.type.name!
    type_dims over->Buffer.type.dims!
    init over->Buffer.init!
    alloc_offset over->Buffer.alloc_offset!
    init_int over->Buffer.init_int!c
    is_static swap->Buffer.is_static!c
}

// ops_dest tok_ptr -- new_tok_ptr
:parse_ref {
    %Token+
    // -- ops_dest tok_ptr
    if viewtd FN_MAP scoped_map_find_idx is_success {
        viewtd FN_MAP scoped_map_find_idx OKind.PUSH_FN 3 roll op_push
        %Token+
        return
    }

    view_buffer_access drop nip
}

// ops_dest tok_ptr -- new_tok_ptr
:parse_eq {
    $ptr original_tok_ptr: {dup}
    if viewtd "=" strcmp {
        %Token+
        over swap parse_buffer_ident
        drop original_tok_ptr

        #macro parse_simple_eq(string, opcode, preop) {
            else if viewtd string strcmp not {
                preop
                0 opcode 3 pick op_push
            }
        }
        if viewtd "/=" strcmp not {
            "swap" call_fn
            0 OKind.DIVMOD 3 pick op_push
            0 OKind.DROP 3 pick op_push
        }
        else if viewtd "%=" strcmp not {
            "swap" call_fn
            0 OKind.DIVMOD 3 pick op_push
            "nip" call_fn
        }
        parse_simple_eq("+=", OKind.ADD,)
        parse_simple_eq("-=", OKind.SUB, "swap" call_fn)
        parse_simple_eq("*=", OKind.MUL,)
        parse_simple_eq("&=", OKind.AND,)
        parse_simple_eq("|=", OKind.OR,)
        parse_simple_eq("^=", OKind.XOR,)
        parse_simple_eq("<<=", OKind.SHL, "swap" call_fn)
        parse_simple_eq(">>=", OKind.SHR, "swap" call_fn)
        parse_simple_eq(">>:=", OKind.SAR, "swap" call_fn)
        else {
            error "Unknown assignment operator '"puts viewtd puts "'\n"puts
            1 exit
        }
    }

    %Token+
    $ptr name: {viewtd}
    $ptr size: {view_buffer_access}
    if size 8 == {
        0 OKind.STORE 3 roll op_push
    } else if size 1 == {
        "storec" call_fn nip
    } else {
        error "Buffer '"puts name puts "' ("puts size put " bytes) cannot be automatically assigned to\n"puts
        1 exit
    }
}

// ops_dest tok_ptr -- new_tok_ptr
:parse_enum {
    %Token+
    if viewtk TKind.IDENT != {
        error "Invalid enum name\n"puts
        1 exit
    }
    // -- tok_ptr
    if swap {
        error "Enum '"puts viewtd puts "' must be defined in global scope\n"puts
        1 exit
    }

    $int scope: {if IS_PUBLIC { NULL } else { SCOPE_STACK stack_last@ }}
    $ptr enum_name: {viewtd}
    $ptr variants_ptr: {ENUM_MEM stack_top}
    enum_name scope check_name_availability

    %Token+
    if viewtk TKind.BRACE_START != {
        error "Invalid enum definition\n"puts
        1 exit
    }

    %Token+
    while viewtk TKind.BRACE_END != {
        if viewtk TKind.IDENT != {
            error "Invalid variant for enum '"puts enum_name puts "'\n"puts
            1 exit
        }

        // -- tok_ptr name variants
        viewtd variants_ptr
        while dup->EnumVariant.name@ {
            if over over->EnumVariant.name@ strcmp not {
                // -- name tok_ptr
                drop swap
                error "Variant '"puts over puts "' already defined for enum '"puts enum_name puts "'\n"puts
                1 exit
            }
            %EnumVariant+
        }

        // -- name tok_ptr
        drop swap %Token+
        if viewtk TKind.COLON == {
            %Token+
            if viewtk TKind.INT != {
                error "Invalid value for enum variant '"puts over puts "'\n"puts
                1 exit
            }
            // -- name tok_ptr value
            viewtd
            if ENUM_MEM stack_last->EnumVariant.name@ {
                if dup ENUM_MEM stack_last->EnumVariant.value@ <= {
                    drop
                    error "Enum '"puts enum_name puts "' must have values in ascending order\n"puts
                    1 exit
                }
            }
            swap %Token+ swap
        } else {
            if ENUM_MEM stack_last->EnumVariant.name@ {
                ENUM_MEM stack_last->EnumVariant.value@ 1+
            } else { 0 }
            // -- name tok_ptr value
        }
        // -- tok_ptr value name slot_ptr
        rot ENUM_MEM stack_push
        swap over->EnumVariant.name! ->EnumVariant.value!
    }
    %Token+

    NULL ENUM_MEM stack_push->EnumVariant.name!

    enum_name scope ENUM_MAP scoped_map_get
    enum_name over->Enum.key.name!
    scope over->Enum.key.scope!
    variants_ptr swap->Enum.variants!
}

// ops_dest tok_ptr -- new_tok_ptr
:parse_struct {
    %Token+
    if viewtk TKind.IDENT != {
        error "Invalid struct name\n"puts
        1 exit
    }
    // -- tok_ptr
    if swap {
        error "Struct '"puts viewtd puts "' must be defined in global scope\n"puts
        1 exit
    }

    $int scope: {if IS_PUBLIC { NULL } else { SCOPE_STACK stack_last@ }}
    $ptr struct_name: {viewtd}
    $ptr fields_ptr: {STRUCT_MEM stack_top}
    struct_name scope check_name_availability

    %Token+
    if viewtk TKind.BRACE_START != {
        error "Invalid struct definition\n"puts
        1 exit
    }

    %Token+
    $int struct_size: {0}
    while viewtk TKind.BRACE_END != {
        $int size
        $ptr type_name: {NULL}
        $ptr type_dims: {NULL}
        if dup tok_is_type {
            view_simple_type =size =type_dims =type_name
        } else if viewtk TKind.BRACKET_START == {
            view_complex_type =size
        } else {
            error "Invalid field type\n"puts
            1 exit
        }

        // -- tok_ptr size
        size
        if over->Token.kind@c TKind.IDENT != {
            drop
            error "Invalid field for struct '"puts struct_name puts "'\n"puts
            1 exit
        }

        // -- tok_ptr size name field
        over->Token.data@ fields_ptr
        while dup->StructField.name@ {
            if over over->StructField.name@ strcmp not {
                // -- name tok_ptr
                drop nip swap
                error "Field '"puts over puts "' already defined for struct '"puts struct_name puts "'\n"puts
                1 exit
            }
            %StructField+
        }
        2 pick +=struct_size

        // -- tok_ptr size name slot_ptr
        drop STRUCT_MEM stack_push
        swap over->StructField.name!
        swap over->StructField.size!
        type_name over->StructField.type.name!
        type_dims swap->StructField.type.dims!
        %Token+
    }
    %Token+
    NULL STRUCT_MEM stack_push->StructField.name!

    struct_name scope STRUCT_MAP scoped_map_get
    struct_name over->Struct.key.name!
    scope over->Struct.key.scope!
    struct_size over->Struct.size!
    fields_ptr swap->Struct.fields!
}

// ops_dest tok_ptr -- new_tok_ptr
:parse_arrow {
    %Token+
    if viewtk TKind.IDENT != {
        error "Invalid struct name after '->'\n"puts
        1 exit
    }

    // -- ops_dest new_tok_ptr type_name
    viewtd swap %Token+ swap
    while view_field_access drop {}
    drop nip
}

// ops_dest tok_ptr -- new_tok_ptr
:parse_size {
    %Token+
    if viewtd STRUCT_MAP scoped_map_find_idx is_success {
        view_type_size
    // -- ops_dest tok_ptr idx
    } else if viewtd BUF_MAP scoped_map_find_idx dup is_success {
        BUF_MAP map_idx->Buffer.size@
    } else {
        drop
        error "Buffer '"puts viewtd puts "' not defined\n"puts
        1 exit
    }
    OKind.PUSH_INT 3 roll op_push
    %Token+
}

// ops_dest tok_ptr -- new_tok_ptr
:parse_call {
    0 OKind.CALL 3 roll op_push
    %Token+
}

// ops_dest tok_ptr -- new_tok_ptr
:parse_tok {
    false =IS_PUBLIC
    if viewtk TKind.PUB == {
        if over {
            error "Public items must be defined at global scope\n"puts
            1 exit
        }

        true =IS_PUBLIC
        %Token+
        if viewtk TKind.FN == { parse_fn }
        else if viewtk TKind.STATIC == { parse_buffer_def }
        else if viewtk TKind.VAR == { parse_buffer_def }
        else if viewtk TKind.ENUM == { parse_enum }
        else if viewtk TKind.STRUCT == { parse_struct }
        else {
            error "Unexpected token of type "puts viewtk put " after 'pub'\n"puts
            1 exit
        }
    }
    else if viewtk TKind.WORD == {
        error "Macro '"puts viewtd puts "' not defined\n"puts
        1 exit
    }
    else if viewtk dup (TKind.INT ==) swap (TKind.CHAR ==) | {
        viewtd OKind.PUSH_INT 3 roll op_push
        %Token+
    }
    else if viewtk TKind.PAREN_START == {
        %Token+
        new_local_scope
        parse_until(TKind.PAREN_END)
        pop_local_scope
        nip
    }
    else if viewtk TKind.STR == { parse_string }
    else if viewtk TKind.IDENT == { parse_ident }
    else if viewtk TKind.IF == { parse_if }
    else if viewtk TKind.WHILE == { parse_while }
    else if viewtk TKind.FOR == { parse_for }
    else if viewtk TKind.CONTINUE == { parse_continue }
    else if viewtk TKind.BREAK == { parse_break }
    else if viewtk TKind.FN == { parse_fn }
    else if viewtk TKind.STATIC == { parse_buffer_def }
    else if viewtk TKind.VAR == { parse_buffer_def }
    else if viewtk TKind.REF == { parse_ref }
    else if viewtk TKind.EQ == { parse_eq }
    else if viewtk TKind.ENUM == { parse_enum }
    else if viewtk TKind.STRUCT == { parse_struct }
    else if viewtk TKind.ARROW == { parse_arrow }
    else if viewtk TKind.SIZE == { parse_size }
    else if viewtk TKind.CALL == { parse_call }
    else if viewtk TKind.FILE_START == {
        dup SCOPE_STACK stack_push!
        nip %Token+
    }
    else if viewtk TKind.FILE_END == {
        &scope_stack stack_shrink
        nip %Token+
    }
    else {
        error "Unexpected token of type "puts viewtk put "\n"puts
        1 exit
    }
}

// kind -- bool
:is_tok_allowed_outside_main {
    $char kind: {}
    (kind TKind.FN ==)
    (kind TKind.STATIC ==)
    (kind TKind.ENUM ==)
    (kind TKind.STRUCT ==)
    (kind TKind.PUB ==)
    (kind TKind.FILE_START ==)
    (kind TKind.FILE_END ==)
    | | | | | |
}

pub :parse_out_toks {
    // -- tok_ptr
    &out_toks_mem->StackHead.data
    while viewtk TKind.EOF != {
        if viewtk is_tok_allowed_outside_main not {
            error "Unexpected token of type "puts viewtk put " outside of 'main'\n"puts
            1 exit
        }
        0 swap parse_tok
    }
    drop

    if "OS_WINDOWS" has_builtin_flag {
        &start_ops_mem swap "__parse_args" call_fn nip
    }
    &start_ops_mem swap "main" call_fn nip
    if "OS_WINDOWS" has_builtin_flag {
        8 OKind.ALLOC &start_ops_mem op_push
    }
    0 OKind.PUSH_INT &start_ops_mem op_push
    0 OKind.EXIT &start_ops_mem op_push
    0 OKind.EOF &start_ops_mem op_push
}