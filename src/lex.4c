#include "std/stdio.4c"
#include "std/stdchar.4c"
#include "std/stdstr.4c"
#include "src/config.4c"
#include "src/stack.4c"
#include "src/token.4c"

// src_ptr --- src_ptr char
:viewc { dup @c }

// src_ptr --- new_src_ptr int
:view_binary_int {
    // total src_ptr
    0 swap
    2+
    while viewc {
        if viewc dup ('0' ==) swap ('1' ==) | {
            viewc '0' -
            rot 2* + swap
        } else if viewc is_alnum {
            "ERROR: Invalid binary integer literal\n".s
            1 exit
        } else if viewc '_' != {
            swap return
        }
        1+
    }
    swap
}
// src_ptr --- new_src_ptr int
:view_hex_int {
    // total src_ptr
    0 swap
    2+
    while viewc {
        if viewc is_digit {
            viewc '0' -
            rot 16* + swap
        } else if viewc to_lower dup ('a' >=) swap ('f' <=) & {
            viewc 'a' - 10 +
            rot 16* + swap
        } else if viewc is_alpha {
            "ERROR: Invalid hexadecimal integer literal\n".s
            1 exit
        } else if viewc '_' != {
            swap return
        }
        1+
    }
    swap
}
// src_ptr --- new_src_ptr int
:view_decimal_int {
    // total src_ptr
    0 swap
    while viewc {
        if viewc is_digit {
            viewc '0' -
            rot 10* + swap
        } else if viewc is_alpha {
            "ERROR: Invalid integer literal\n".s
            1 exit
        } else if viewc '_' != {
            swap return
        }
        1+
    }
    swap
}
// src_ptr --- new_src_ptr int
:view_int {
    if viewc '-' == {
        -1 swap 1+
    } else {
        1 swap
    } // scalar src_ptr

    if (viewc '0' ==) (over 1+ @c 'b' ==) & {
        view_binary_int
    } else if (viewc '0' ==) (over 1+ @c 'x' ==) & {
        view_hex_int
    } else {
        view_decimal_int
    } // scalar src_ptr int
    rot *
}

// src_ptr --- src_ptr char
:match_char {
    if viewc '\\' == {
        1+
        // null
        if viewc '0' == { '\0' }
        // newline
        else if viewc 'n' == { '\n' }
        // tab
        else if viewc 't' == { '\t' }
        // vertical tab
        else if viewc 'v' == { '\v' }
        // form feed
        else if viewc 'f' == { '\f' }
        // return
        else if viewc 'r' == { '\r' }
        // single quote
        else if viewc '\'' == { '\'' }
        // double quote
        else if viewc '\"' == { '\"' }
        // backslash
        else if viewc '\\' == { '\\' }
        else {
            "ERROR: Invalid escape character '\\".s viewc.c "'\n".s
            1 exit
        }
    } else { viewc }
}

// src_ptr --- new_src_ptr char
:view_char {
    1+
    match_char
    swap 1+

    if viewc '\'' != {
        "ERROR: Expected endquote after valid character '".s swap .c "'\n".s
        1 exit
    }

    1+ swap
    return
}

// src_ptr --- new_src_ptr ref
:view_str {
    &strs_mem stack_topc swap
    1+
    while viewc '\"' != {
        match_char &strs_mem stack_pushc
        1+
    }
    1+
    0 &strs_mem stack_pushc
    swap
}

// char -- bool
:is_ident_char {
    dup (is_alnum) swap ('_' ==) |
}

// src_ptr --- new_src_ptr ref
:view_ident {
    &strs_mem stack_topc swap
    viewc &strs_mem stack_pushc
    while 1+ viewc {
        if viewc is_ident_char not {
            0 &strs_mem stack_pushc
            swap
            return
        }
        viewc &strs_mem stack_pushc
    }
    0 &strs_mem stack_pushc
    swap
}

// src_ptr --- new_src_ptr
:lex_ident {
    view_ident

    // new_src_ptr ref
    if dup "if" str_eq {
        0 TOK_IF &toks_mem toks_push
    } else if dup "else" str_eq {
        0 TOK_ELSE &toks_mem toks_push
    } else if dup "while" str_eq {
        0 TOK_WHILE &toks_mem toks_push
    } else if dup "static" str_eq {
        0 TOK_STATIC &toks_mem toks_push
    } else {
        TOK_IDENT &toks_mem toks_push
        return
    }

    // new_src_ptr n_chars
    &strs_mem stack_topc swap -
    &strs_mem stack_len swap - &strs_mem!
}

// src_ptr --- new_src_ptr ref
:view_word {
    &strs_mem stack_topc swap
    while ("(){}[]" over@c str_char not) (over@c is_space not) & (over@c bool) & {
        viewc &strs_mem stack_pushc
        1+
    }
    0 &strs_mem stack_pushc
    swap
}

#lex_trivial(trivial_char trivial_tok) {
    else if viewc trivial_char == {
        0 trivial_tok &toks_mem toks_push
        1+
    }
}

// src_ptr ---
:lex_src {
    while viewc {
        while viewc is_space { 1+ }
        if viewc not {
            drop
            0 TOK_EOF &toks_mem toks_push
            return
        } else if ((viewc '-' ==) (over 1+ @c is_digit) &) (over@c is_digit) | {
            view_int TOK_INT &toks_mem toks_push
        } else if viewc '\'' == {
            view_char TOK_CHAR &toks_mem toks_push
        } else if viewc '\"' == {
            view_str TOK_STR &toks_mem toks_push
        } else if (viewc '&' ==) (over 1+ @c is_ident_char) & {
            1+
            view_ident TOK_REF &toks_mem toks_push
        } else if (viewc ':' ==) (over 1+ @c is_ident_char) & {
            1+
            view_ident TOK_FN &toks_mem toks_push
        } else if (viewc '=' ==) (over 1+ @c is_ident_char) & {
            1+
            view_ident TOK_EQ &toks_mem toks_push
        } else if (viewc '/' ==) (over 1+ @c '/' ==) & {
            while viewc dup ('\n' !=) swap (bool) & { 1+ }
        }
        lex_trivial(':' TOK_COLON)
        lex_trivial('#' TOK_POUND)
        lex_trivial('$' TOK_DOLLAR)
        lex_trivial('(' TOK_PAREN_START)
        lex_trivial(')' TOK_PAREN_END)
        lex_trivial('{' TOK_BRACE_START)
        lex_trivial('}' TOK_BRACE_END)
        lex_trivial('[' TOK_BRACKET_START)
        lex_trivial(']' TOK_BRACKET_END)
        else if viewc is_ident_char {
            lex_ident
        } else {
            view_word TOK_WORD &toks_mem toks_push
        }
    }
    drop
    0 TOK_EOF &toks_mem toks_push
}