#use "stdio.4c"
#use "stdchar.4c"
#use "stdstr.4c"
#use "config.4c"
#use "stack.4c"
#use "token.4c"

$static int line
$static ptr file

// src_ptr -- src_ptr char
:viewc { dup@c }

// src_ptr -- new_src_ptr int
:view_binary_int {
    // -- total src_ptr
    0 swap
    2+
    while viewc {
        if viewc dup ('0' ==) swap ('1' ==) | {
            viewc '0' -
            rot 2* + swap
        } else if viewc is_alnum {
            error "Invalid binary integer literal\n"puts
            1 exit
        } else if viewc '_' != {
            swap return
        }
        1+
    }
    swap
}

// src_ptr -- new_src_ptr int
:view_hex_int {
    // -- total src_ptr
    0 swap
    2+
    while viewc {
        if viewc is_digit {
            viewc '0' -
            rot 16* + swap
        } else if viewc to_lower dup ('a' >=) swap ('f' <=) & {
            viewc 'a' - 10 +
            rot 16* + swap
        } else if viewc is_alpha {
            error "Invalid hexadecimal integer literal\n"puts
            1 exit
        } else if viewc '_' != {
            swap return
        }
        1+
    }
    swap
}

// src_ptr -- new_src_ptr int
:view_decimal_int {
    // -- total src_ptr
    0 swap
    while viewc {
        if viewc is_digit {
            viewc '0' -
            rot 10* + swap
        } else if viewc is_alpha {
            error "Invalid integer literal\n"puts
            1 exit
        } else if viewc '_' != {
            swap return
        }
        1+
    }
    swap
}

// src_ptr -- new_src_ptr int
:view_int {
    if viewc '-' == {
        -1 swap 1+
    } else {
        1 swap
    } // -- scalar src_ptr

    if (viewc '0' ==) (over 1+ @c 'b' ==) & {
        view_binary_int
    } else if (viewc '0' ==) (over 1+ @c 'x' ==) & {
        view_hex_int
    } else {
        view_decimal_int
    } // -- scalar src_ptr int
    rot *
}

// src_ptr -- src_ptr char
:match_char {
    if viewc '\\' == {
        1+
        // null
        if viewc '0' == { '\0' }
        // newline
        else if viewc 'n' == { '\n' }
        // tab
        else if viewc 't' == { '\t' }
        // vertical tab
        else if viewc 'v' == { '\v' }
        // form feed
        else if viewc 'f' == { '\f' }
        // return
        else if viewc 'r' == { '\r' }
        // single quote
        else if viewc '\'' == { '\'' }
        // double quote
        else if viewc '\"' == { '\"' }
        // backslash
        else if viewc '\\' == { '\\' }
        else {
            error "Invalid escape character '\\"puts viewc putc "'\n"puts
            1 exit
        }
    } else { viewc }
}

// src_ptr -- new_src_ptr char
:view_char {
    1+
    match_char
    swap 1+

    if viewc '\'' != {
        error "Expected endquote after valid character '"puts swap putc "'\n"puts
        1 exit
    }

    1+ swap
    return
}

// src_ptr -- new_src_ptr ref
:view_str {
    STRS_MEM stack_top swap
    1+
    while viewc '\"' != {
        if viewc '\n' == { 1 +=line }
        match_char STRS_MEM stack_push!c
        1+
    }
    1+
    0 STRS_MEM stack_push!c
    swap
}

:is_ident_first_char {
    dup (is_alpha) swap ('_' ==) |
}
:is_ident_any_char {
    dup (is_alnum) swap ('_' ==) |
}

// src_ptr -- new_src_ptr ref
:view_ident {
    STRS_MEM stack_top swap
    viewc STRS_MEM stack_push!c
    while 1+ viewc {
        if viewc is_ident_any_char not {
            0 STRS_MEM stack_push!c
            swap
            return
        }
        viewc STRS_MEM stack_push!c
    }
    0 STRS_MEM stack_push!c
    swap
}

#macro match_ident_token(token_str, token_id) {
    if dup token_str streq {
        0 token_id file line &toks_mem tok_push
        // -- new_src_ptr n_chars
        STRS_MEM stack_top swap -
        &strs_mem stack_len swap - &strs_mem!
        return
    }
}

// src_ptr -- new_src_ptr
:lex_ident {
    view_ident
    match_ident_token("if", TKind.IF)
    match_ident_token("else", TKind.ELSE)
    match_ident_token("while", TKind.WHILE)
    match_ident_token("static", TKind.STATIC)
    match_ident_token("enum", TKind.ENUM)
    match_ident_token("struct", TKind.STRUCT)
    match_ident_token("call", TKind.CALL)
    match_ident_token("pub", TKind.PUB)
    TKind.IDENT file line &toks_mem tok_push
    return
}

// src_ptr -- src_ptr bool
:continue_lexing_word {
    $char c: {viewc}
    ("(){}[]," c strchr not)
    (c is_space not) &
    (c flag) &
    ((STRS_MEM stack_last@c '=' !=) (c '=' ==) |) &
}

// src_ptr -- new_src_ptr ref
:view_word {
    STRS_MEM stack_top swap
    $char c
    while continue_lexing_word {
        viewc STRS_MEM stack_push!c
        1+
    }
    0 STRS_MEM stack_push!c
    swap
}

#macro lex_tagged_ident(tag_char, token_id) {
    else if (viewc tag_char ==) (over 1+ @c is_ident_first_char) & {
        0 token_id file line &toks_mem tok_push
        1+
    }
}

#macro lex_single(token_char, token_id) {
    else if viewc token_char == {
        0 token_id file line &toks_mem tok_push
        1+
    }
}

// src_ptr file --
:pub lex_src {
    =file
    1 =line
    while viewc {
        while viewc is_space {
            if viewc '\n' == { 1 +=line }
            1+
        }
        if viewc not {
            drop
            0 TKind.EOF file line &toks_mem tok_push
            return
        } else if ((viewc '-' ==) (over 1+ @c is_digit) &) (over@c is_digit) | {
            view_int TKind.INT file line &toks_mem tok_push
        } else if viewc '\'' == {
            view_char TKind.CHAR file line &toks_mem tok_push
        } else if viewc '\"' == {
            view_str TKind.STR file line &toks_mem tok_push
        }
        lex_tagged_ident('&', TKind.REF)
        lex_tagged_ident(':', TKind.FN)
        lex_tagged_ident('.', TKind.FIELD)
        lex_tagged_ident('%', TKind.SIZE)
        else if (viewc '/' ==) (over 1+ @c '/' ==) & {
            while viewc dup ('\n' !=) swap (flag) & { 1+ }
        } else if (viewc '-' ==) (over 1+ @c '>' ==) & {
            0 TKind.ARROW file line &toks_mem tok_push
            2+
        }
        lex_single(':', TKind.COLON)
        lex_single('#', TKind.POUND)
        lex_single(',', TKind.COMMA)
        lex_single('$', TKind.DOLLAR)
        lex_single('(', TKind.PAREN_START)
        lex_single(')', TKind.PAREN_END)
        lex_single('{', TKind.BRACE_START)
        lex_single('}', TKind.BRACE_END)
        lex_single('[', TKind.BRACKET_START)
        lex_single(']', TKind.BRACKET_END)
        else if viewc is_ident_first_char {
            lex_ident
        } else {
            view_word
            if over@c is_ident_first_char { TKind.EQ } else { TKind.WORD }
            file line &toks_mem tok_push
        }
    }
    drop
    0 TKind.EOF file line &toks_mem tok_push
}