#include "std/stdio.4c"
#include "std/stdchar.4c"
#include "std/stdstr.4c"
#include "src/config.4c"
#include "src/stack.4c"
#include "src/token.4c"

// src_ptr -- src_ptr char
:viewc { dup @c }

// src_ptr -- new_src_ptr int
:view_binary_int {
    // -- total src_ptr
    0 swap
    2+
    while viewc {
        if viewc dup ('0' ==) swap ('1' ==) | {
            viewc '0' -
            rot 2* + swap
        } else if viewc is_alnum {
            "ERROR: Invalid binary integer literal\n"eputs
            1 exit
        } else if viewc '_' != {
            swap return
        }
        1+
    }
    swap
}
// src_ptr -- new_src_ptr int
:view_hex_int {
    // -- total src_ptr
    0 swap
    2+
    while viewc {
        if viewc is_digit {
            viewc '0' -
            rot 16* + swap
        } else if viewc to_lower dup ('a' >=) swap ('f' <=) & {
            viewc 'a' - 10 +
            rot 16* + swap
        } else if viewc is_alpha {
            "ERROR: Invalid hexadecimal integer literal\n"eputs
            1 exit
        } else if viewc '_' != {
            swap return
        }
        1+
    }
    swap
}
// src_ptr -- new_src_ptr int
:view_decimal_int {
    // -- total src_ptr
    0 swap
    while viewc {
        if viewc is_digit {
            viewc '0' -
            rot 10* + swap
        } else if viewc is_alpha {
            "ERROR: Invalid integer literal\n"eputs
            1 exit
        } else if viewc '_' != {
            swap return
        }
        1+
    }
    swap
}
// src_ptr -- new_src_ptr int
:view_int {
    if viewc '-' == {
        -1 swap 1+
    } else {
        1 swap
    } // -- scalar src_ptr

    if (viewc '0' ==) (over 1+ @c 'b' ==) & {
        view_binary_int
    } else if (viewc '0' ==) (over 1+ @c 'x' ==) & {
        view_hex_int
    } else {
        view_decimal_int
    } // -- scalar src_ptr int
    rot *
}

// src_ptr -- src_ptr char
:match_char {
    if viewc '\\' == {
        1+
        // null
        if viewc '0' == { '\0' }
        // newline
        else if viewc 'n' == { '\n' }
        // tab
        else if viewc 't' == { '\t' }
        // vertical tab
        else if viewc 'v' == { '\v' }
        // form feed
        else if viewc 'f' == { '\f' }
        // return
        else if viewc 'r' == { '\r' }
        // single quote
        else if viewc '\'' == { '\'' }
        // double quote
        else if viewc '\"' == { '\"' }
        // backslash
        else if viewc '\\' == { '\\' }
        else {
            "ERROR: Invalid escape character '\\"eputs viewc eputc "'\n"eputs
            1 exit
        }
    } else { viewc }
}

// src_ptr -- new_src_ptr char
:view_char {
    1+
    match_char
    swap 1+

    if viewc '\'' != {
        "ERROR: Expected endquote after valid character '"eputs swap eputc "'\n"eputs
        1 exit
    }

    1+ swap
    return
}

// src_ptr -- new_src_ptr ref
:view_str {
    &strs_mem %char stack_top swap
    1+
    while viewc '\"' != {
        match_char &strs_mem %char stack_push!c
        1+
    }
    1+
    0 &strs_mem %char stack_push!c
    swap
}

:is_ident_first_char {
    dup (is_alpha) swap ('_' ==) |
}
:is_ident_any_char {
    dup (is_alnum) swap ('_' ==) |
}

// src_ptr -- new_src_ptr ref
:view_ident {
    &strs_mem %char stack_top swap
    viewc &strs_mem %char stack_push!c
    while 1+ viewc {
        if viewc is_ident_any_char not {
            0 &strs_mem %char stack_push!c
            swap
            return
        }
        viewc &strs_mem %char stack_push!c
    }
    0 &strs_mem %char stack_push!c
    swap
}

#match_ident_token(token_str token_id) {
    if dup token_str str_eq {
        0 token_id &toks_mem tok_push
        // -- new_src_ptr n_chars
        &strs_mem %char stack_top swap -
        &strs_mem stack_len swap - &strs_mem!
        return
    }
}

// src_ptr -- new_src_ptr
:lex_ident {
    view_ident
    match_ident_token("if" TOK_IF)
    match_ident_token("else" TOK_ELSE)
    match_ident_token("while" TOK_WHILE)
    match_ident_token("static" TOK_STATIC)
    match_ident_token("struct" TOK_STRUCT)
    match_ident_token("call" TOK_CALL)
    TOK_IDENT &toks_mem tok_push
    return
}

// src_ptr -- new_src_ptr ref
:view_word {
    &strs_mem %char stack_top swap
    while ("(){}[]" over@c str_char not) (over@c is_space not) & (over@c flag) & {
        viewc &strs_mem %char stack_push!c
        1+
    }
    0 &strs_mem %char stack_push!c
    swap
}

#lex_tagged_ident(tag_char token_id) {
    else if (viewc tag_char ==) (over 1+ @c is_ident_first_char) & {
        1+
        view_ident token_id &toks_mem tok_push
    }
}

#lex_single(token_char token_id) {
    else if viewc token_char == {
        1+
        0 token_id &toks_mem tok_push
    }
}

// src_ptr --
:lex_src {
    while viewc {
        while viewc is_space { 1+ }
        if viewc not {
            drop
            0 TOK_EOF &toks_mem tok_push
            return
        } else if ((viewc '-' ==) (over 1+ @c is_digit) &) (over@c is_digit) | {
            view_int TOK_INT &toks_mem tok_push
        } else if viewc '\'' == {
            view_char TOK_CHAR &toks_mem tok_push
        } else if viewc '\"' == {
            view_str TOK_STR &toks_mem tok_push
        }
        lex_tagged_ident('&' TOK_REF)
        lex_tagged_ident(':' TOK_FN)
        lex_tagged_ident('=' TOK_EQ)
        lex_tagged_ident('.' TOK_FIELD)
        lex_tagged_ident('%' TOK_SIZE)
        else if (viewc '/' ==) (over 1+ @c '/' ==) & {
            while viewc dup ('\n' !=) swap (flag) & { 1+ }
        } else if (viewc '-' ==) (over 1+ @c '>' ==) & {
            2+
            0 TOK_ARROW &toks_mem tok_push
        }
        lex_single(':' TOK_COLON)
        lex_single('#' TOK_POUND)
        lex_single('$' TOK_DOLLAR)
        lex_single('(' TOK_PAREN_START)
        lex_single(')' TOK_PAREN_END)
        lex_single('{' TOK_BRACE_START)
        lex_single('}' TOK_BRACE_END)
        lex_single('[' TOK_BRACKET_START)
        lex_single(']' TOK_BRACKET_END)
        else if viewc is_ident_first_char {
            lex_ident
        } else {
            view_word TOK_WORD &toks_mem tok_push
        }
    }
    drop
    0 TOK_EOF &toks_mem tok_push
}