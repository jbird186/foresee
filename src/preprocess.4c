#use "src/config.4c"
#use "src/token.4c"
#use "src/map.4c"

// tok_ptr -- new_tok_ptr
:preprocess_token

// tok_ptr --
:preprocess {
    while viewtk { preprocess_token }
    drop
}

// tok_ptr -- new_tok_ptr
:skip_braces {
    // -- depth tok_ptr
    1 swap while %Token+ over {
        if viewtk TKind.BRACE_START == {
            swap 1+ swap
        } else if viewtk TKind.BRACE_END == {
            swap 1- swap
        }
    }
    // -- tok_ptr
    nip
}

// tok_ptr --
:preprocess_macro_block {
    %Token+
    // -- depth tok_ptr
    1 swap while over {
        if viewtk TKind.BRACE_START == {
            swap 1+ swap
        } else if viewtk TKind.BRACE_END == {
            swap 1- swap
        }
        if over {
            preprocess_token
        }
    }
    %Token+
    drop drop
}

// token_kind -- bool
:is_tagged_ident {
    // token_kind
    dup (TKind.REF ==) swap
    dup (TKind.FN ==) swap
    dup (TKind.EQ ==) swap
    dup (TKind.FIELD ==) swap
    (TKind.SIZE ==)
    | | | |
}
// token_kind -- bool
:is_macro_replaceable {
    // token_kind
    dup (TKind.IDENT ==) swap
    dup (TKind.WORD ==) swap
    is_tagged_ident
    | |
}

// tok_ptr -- tok_ptr bool
:check_use {
    if viewtk TKind.IDENT == {
        viewtd "use" str_eq
    } else {
        false
    }
}

// name -- [idx, -1]
:scoped_macro_idx {
    $static int scope_idx
    &scope_stack stack_len =scope_idx

    while &scope_idx@-- {
        if dup scope_idx SCOPE_STACK stack_get@ MACRO_MAP scoped_map_contains {
            scope_idx SCOPE_STACK stack_get@ MACRO_MAP scoped_map_get_idx
            return
        }
    }
    drop -1
}

// tok_ptr -- new_tok_ptr
:preprocess_word {
    $static char arg_kind
    viewtk =arg_kind

    // -- name tok_ptr
    viewtd swap
    // -- name tok_ptr macro_idx
    if over scoped_macro_idx dup is_success {
        MACRO_MAP map_idx->Macro.toks@
        dup SCOPE_STACK stack_push!
        swap %Token+ swap
        // Arguments (optional)
        if viewtk TKind.PAREN_START == {
            // -- name def_tok_ptr tok_ptr
            swap
            if viewtk TKind.PAREN_START != {
                error "Expected arguments for macro '"eputs 2 pick eputs "'\n"eputs
                1 exit
            }
            %Token+

            // -- name tok_ptr def_tok_ptr
            while swap %Token+ viewtk TKind.PAREN_END != {
                // TODO: prevent name collision between macros and macro arguments
                // -- name tok_ptr def_tok_ptr slot_ptr
                viewtd MACRO_MAP map_get
                over->Token.data@ over->Macro.key->ScopedKey.name!
                SCOPE_STACK stack_last@ over->Macro.key->ScopedKey.scope!
                2 pick swap->Macro.toks!
                // -- name def_tok_ptr tok_ptr
                swap
                if viewtk TKind.BRACE_START == {
                    skip_braces
                } else if viewtk TKind.PAREN_END == {
                    error "Invalid number of arguments supplied to macro '"eputs 2 pick eputs "'\n"eputs
                    1 exit
                } else {
                    %Token+
                }
            }
            // -- name def_tok_ptr tok_ptr
            %Token+ swap
            if viewtk TKind.PAREN_END != {
                error "Invalid number of arguments supplied to macro '"eputs 2 pick eputs "'\n"eputs
                1 exit
            }
            // -- name tok_ptr def_tok_ptr
            %Token+ swap
        }
        if viewtk TKind.BRACE_START == {
            // -- tok_ptr def_tok_ptr
            rot drop
            preprocess_macro_block
        } else {
            if arg_kind is_tagged_ident {
                if viewtk TKind.IDENT != {
                    error "Macro expansion for '"eputs 2 pick eputs "' expected ident, found tagged ident\n"eputs
                    1 exit
                }
                arg_kind over!c
            }
            preprocess_token
            drop nip
        }
        &scope_stack stack_shrink
    } else {
        // -- tok_ptr
        drop nip
        dup &out_toks_mem tok_dup
        %Token+
    }
}

// tok_ptr -- new_tok_ptr
:preprocess_use {
    %Token+
    if viewtk TKind.STR != {
        error "Expected file name after 'use' directive\n"eputs
        1 exit
    }

    // Check if this file has already been used
    if viewtd FILE_SET map_contains {
        %Token+
        return
    }
    viewtd dup FILE_SET map_get->File.name!

    // -- tok_ptr fd
    if viewtd 0 fopen dup is_failure {
        drop
        error "'use' directive failed to open file '"eputs swap viewtd eputs "'\n"eputs
        1 exit
    }
    // -- tok_ptr fd bytes_read
    if &src_str SRC_STR_SIZE 2 pick fread dup is_failure {
        drop drop
        error "'use' directive failed to read file '"eputs swap viewtd eputs "'\n"eputs
        1 exit
    }
    // -- tok_ptr fd
    &src_str+ 0 swap!c

    // -- tok_ptr
    if fclose is_failure {
        error "'use' directive failed to close file '"eputs swap viewtd eputs "'\n"eputs
        1 exit
    }

    // -- tok_ptr use_tok_ptr
    &toks_mem %Token stack_top
    over->Token.data@ &src_str swap lex_src

    preprocess
    %Token+
}

// tok_ptr -- new_tok_ptr
:preprocess_macro_def {
    if viewtd MACRO_MAP map_contains {
        error "Macro '"eputs viewtd eputs "' already defined\n"eputs
        1 exit
    }
    // -- name tok_ptr
    viewtd swap %Token+
    // -- name tok_ptr slot_ptr
    over MACRO_MAP map_get
    over over->Macro.toks!
    SCOPE_STACK stack_last@ over->Macro.key->ScopedKey.scope!
    2 pick swap->Macro.key->ScopedKey.name!

    // Arguments (optional)
    // -- name tok_ptr
    if viewtk TKind.PAREN_START == {
        while %Token+ viewtk TKind.PAREN_END != {
            if viewtk TKind.IDENT != {
                error "Invalid parameter in definition for macro '"eputs over eputs "'\n"eputs
                1 exit
            }
        }
        %Token+
    }

    if viewtk TKind.BRACE_START != {
        error "Invalid body for macro '"eputs over eputs "'\n"eputs
        1 exit
    }
    // -- tok_ptr
    nip
    skip_braces
}

// tok_ptr -- new_tok_ptr
:preprocess_pound {
    %Token+
    if check_use {
        preprocess_use
    } else if viewtk dup (TKind.IDENT ==) swap (TKind.WORD ==) | {
        preprocess_macro_def
    } else {
        error "Unexpected preprocessor directive\n"eputs
        1 exit
    }
}

// tok_ptr -- new_tok_ptr
:preprocess_token {
    if viewtk is_macro_replaceable {
        preprocess_word
    } else if viewtk TKind.POUND == {
        preprocess_pound
    } else {
        dup &out_toks_mem tok_dup
        %Token+
    }
}

:preprocess_src {
    &toks_mem->StackHead.data preprocess
    0 TKind.EOF 0 0 &out_toks_mem tok_push
}