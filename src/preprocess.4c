#use "config.4c"
#use "token.4c"
#use "map.4c"

// tok_ptr -- new_tok_ptr
:preprocess_token

// tok_ptr --
:preprocess {
    while viewtk { preprocess_token }
    drop
}

// tok_ptr -- new_tok_ptr
:skip_braces {
    // -- depth tok_ptr
    1 swap while %Token+ over {
        if viewtk TKind.BRACE_START == {
            swap 1+ swap
        } else if viewtk TKind.BRACE_END == {
            swap 1- swap
        }
    }
    // -- tok_ptr
    nip
}

// tok_ptr -- tok_ptr
:preprocess_block {
    %Token+
    // -- depth tok_ptr
    1 swap while over {
        if viewtk TKind.BRACE_START == {
            swap 1+ swap
        } else if viewtk TKind.BRACE_END == {
            swap 1- swap
        }
        if over {
            preprocess_token
        }
    }
    nip %Token+
}

// tok_ptr -- new_tok_ptr
:preprocess_word {
    $char arg_kind: {viewtk}

    // -- name tok_ptr
    viewtd swap
    // -- name tok_ptr macro_idx
    if over MACRO_MAP scoped_map_find_idx dup is_success {
        MACRO_MAP map_idx->Macro.toks@
        if dup not {
            drop
            error "Attempted to expand preprocessor flag '"eputs swap eputs "'\n"eputs
            1 exit
        }

        dup SCOPE_STACK stack_push!
        swap %Token+ swap
        // Arguments (optional)
        if viewtk TKind.PAREN_START == {
            // -- name def_tok_ptr tok_ptr
            swap
            if viewtk TKind.PAREN_START != {
                error "Expected arguments for macro '"eputs 2 pick eputs "'\n"eputs
                1 exit
            }
            %Token+

            // -- name tok_ptr def_tok_ptr
            while swap %Token+ viewtk TKind.PAREN_END != {
                // -- name tok_ptr def_tok_ptr slot_ptr
                viewtd SCOPE_STACK stack_last@ MACRO_MAP scoped_map_get
                over->Token.data@ over->Macro.key.name!
                SCOPE_STACK stack_last@ over->Macro.key.scope!
                2 pick swap->Macro.toks!
                // -- name def_tok_ptr tok_ptr
                swap
                if viewtk TKind.BRACE_START == {
                    skip_braces
                } else if viewtk TKind.PAREN_END == {
                    error "Invalid number of arguments supplied to macro '"eputs 2 pick eputs "'\n"eputs
                    1 exit
                } else {
                    %Token+
                }
            }
            // -- name def_tok_ptr tok_ptr
            %Token+ swap
            if viewtk TKind.PAREN_END != {
                error "Invalid number of arguments supplied to macro '"eputs 2 pick eputs "'\n"eputs
                1 exit
            }
            // -- name tok_ptr def_tok_ptr
            %Token+ swap
        }
        if viewtk TKind.BRACE_START == {
            // -- tok_ptr def_tok_ptr
            rot drop
            preprocess_block drop
        } else {
            preprocess_token
            drop nip
        }
        &scope_stack stack_shrink
    } else {
        // -- tok_ptr
        drop nip
        dup &out_toks_mem tok_dup
        %Token+
    }
}

// path -- name
:_file_name {
    $ptr name: {}
    name while dup@c {
        if dup@c '/' == {
            dup 1+ =name
        }
        %char+
    } drop
    name
}

// name -- file_path fd
:_open_file {
    $ptr name: {}
    $int idx: {0}
    while idx &dirs_mem stack_len < {
        $char[256] file_path
        idx DIRS_MEM stack_get@ &file_path strcpy
        name &file_path strcat

        $ptr fd: {&file_path 0 fopen}
        if fd is_success {
            &file_path fd return
        }

        idx 1+ =idx
    }
    NULL -1 return
}

// name --
:pub use_file {
    $ptr name: {}
    if name _file_name FILE_SET map_contains {
        return
    }

    name _open_file
    $ptr fd: {}
    $ptr path: {}

    if fd is_failure {
        error "'use' directive failed to open file '"eputs name eputs "'\n"eputs
        1 exit
    }
    name _file_name dup FILE_SET map_get!

    $int read_res: {&src_str SRC_STR_SIZE fd fread }
    if read_res is_failure {
        error "'use' directive failed to read file '"eputs path eputs "'\n"eputs
        1 exit
    }
    0 (read_res &src_str+)!c

    if fd fclose is_failure {
        error "'use' directive failed to close file '"eputs path eputs "'\n"eputs
        1 exit
    }

    dup SCOPE_STACK stack_push!
    // -- tok_ptr use_tok_ptr
    &toks_mem %Token stack_top
    &src_str name lex_src
    0 TKind.FILE_START name 0 &out_toks_mem tok_push
    preprocess
    0 TKind.FILE_END name 0 &out_toks_mem tok_push
    &scope_stack stack_shrink
}

// tok_ptr -- new_tok_ptr
:parse_use_directive {
    %Token+
    if viewtk TKind.STR != {
        error "Expected file name for 'use' directive\n"eputs
        1 exit
    }
    viewtd use_file %Token+
}

// tok_ptr -- new_tok_ptr
:parse_error_directive {
    %Token+
    if viewtk TKind.STR == {
        error viewtd eputs
    } else {
        error "Expected message for 'error' directive\n"eputs
    }
    1 exit
}

// tok_ptr -- new_tok_ptr
:parse_macro_directive {
    %Token+
    if viewtk dup (TKind.IDENT !=) swap (TKind.WORD !=) & {
        error "Expected name for 'macro' directive\n"eputs
        1 exit
    }
    if viewtd SCOPE_STACK stack_last@ MACRO_MAP scoped_map_contains {
        error "Macro '"eputs viewtd eputs "' already defined in this scope\n"eputs
        1 exit
    }
    // -- name tok_ptr
    viewtd swap %Token+
    $int scope: {if IS_PUBLIC { NULL } else { SCOPE_STACK stack_last@ }}

    // -- name tok_ptr slot_ptr
    over scope MACRO_MAP scoped_map_get
    over over->Macro.toks!
    scope over->Macro.key.scope!
    2 pick swap->Macro.key.name!

    // Arguments (optional)
    // -- name tok_ptr
    if viewtk TKind.PAREN_START == {
        while %Token+ viewtk TKind.PAREN_END != {
            if viewtk TKind.IDENT != {
                error "Invalid parameter in definition for macro '"eputs over eputs "'\n"eputs
                1 exit
            }
        }
        %Token+
    }

    if viewtk TKind.BRACE_START != {
        error "Invalid body for macro '"eputs over eputs "'\n"eputs
        1 exit
    }
    // -- tok_ptr
    nip skip_braces
}

// tok_ptr -- new_tok_ptr
:parse_flag_directive {
    %Token+
    if viewtk TKind.IDENT != {
        error "Expected identifier for 'flag' directive\n"eputs
        1 exit
    }
    if viewtd SCOPE_STACK stack_last@ MACRO_MAP scoped_map_contains {
        error "Macro '"eputs viewtd eputs "' already defined in this scope\n"eputs
        1 exit
    }

    $int scope: {if IS_PUBLIC { NULL } else { SCOPE_STACK stack_last@ }}
    viewtd
    dup scope MACRO_MAP scoped_map_get
    swap over->Macro.key.name!
    scope over->Macro.key.scope!
    NULL swap->Macro.toks!
    %Token+
}

// tok_ptr -- new_tok_ptr
:parse_undef_directive {
    %Token+
    if viewtk dup (TKind.IDENT !=) swap (TKind.WORD !=) & {
        error "Expected macro name for 'undef' directive\n"eputs
        1 exit
    }
    if viewtd MACRO_MAP scoped_map_find_idx is_failure {
        error "Macro '"eputs viewtd eputs "' not defined\n"eputs
        1 exit
    }

    viewtd MACRO_MAP scoped_map_find_idx MACRO_MAP map_idx
    NULL over->Macro.key.name!
    NULL over->Macro.key.scope!
    NULL swap->Macro.toks!
    %Token+
}

// tok_ptr -- new_tok_ptr
#macro parse_if_directive(true_case false_case) {
    %Token+
    if viewtk dup (TKind.IDENT !=) swap (TKind.WORD !=) & {
        error "Expected macro name for 'if' directive\n"eputs
        1 exit
    }

    // -- macro_name tok_ptr
    viewtd swap %Token+
    if viewtk TKind.BRACE_START != {
        error "Expected braces for 'if' directive\n"eputs
        1 exit
    }

    if swap MACRO_MAP scoped_map_find_idx is_success {
        true_case
    } else {
        false_case
    }
}

// tok_ptr -- new_tok_ptr
:preprocess_pound {
    %Token+
    if viewtk TKind.PUB == {
        true =IS_PUBLIC
        %Token+
        if viewtd "macro" streq { parse_macro_directive }
        else if viewtd "flag" streq { parse_flag_directive }
        else {
            error "Unknown preprocessor directive '"eputs viewtd eputs "'\n"eputs
            1 exit
        }
        false =IS_PUBLIC
        return
    }

    if viewtk TKind.IDENT != {
        error "Invalid preprocessor directive\n"eputs
        1 exit
    }
    if viewtd "use" streq { parse_use_directive }
    else if viewtd "error" streq { parse_error_directive }
    else if viewtd "macro" streq { parse_macro_directive }
    else if viewtd "flag" streq { parse_flag_directive }
    else if viewtd "undef" streq { parse_undef_directive }
    else if viewtd "ifdef" streq { parse_if_directive(preprocess_block skip_braces) }
    else if viewtd "ifndef" streq { parse_if_directive(skip_braces preprocess_block) }
    else {
        error "Unknown preprocessor directive '"eputs viewtd eputs "'\n"eputs
        1 exit
    }
}

// tok_ptr -- new_tok_ptr
:preprocess_token {
    if viewtk dup (TKind.IDENT ==) swap (TKind.WORD ==) | {
        preprocess_word
    } else if viewtk TKind.POUND == {
        preprocess_pound
    } else {
        if viewtk TKind.BRACE_START == {
            dup SCOPE_STACK stack_push!
        } else if viewtk TKind.BRACE_END == {
            &scope_stack stack_shrink
        }
        dup &out_toks_mem tok_dup
        %Token+
    }
}

:pub preprocess_src {
    &toks_mem->StackHead.data preprocess
    0 TKind.EOF NULL 0 &out_toks_mem tok_push
}

// name --
:pub define_builtin_flag {
    dup SCOPE_STACK stack_last@ MACRO_MAP scoped_map_get
    NULL over->Macro.toks!
    NULL over->Macro.key.scope!
    ->Macro.key.name!
}

// name -- bool
:pub has_builtin_flag {
    MACRO_MAP scoped_map_find_idx is_success
}