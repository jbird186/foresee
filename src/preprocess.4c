#include "src/config.4c"
#include "src/token.4c"
#include "src/map.4c"

// tok_ptr -- new_tok_ptr
:preprocess_token

// tok_ptr --
:preprocess {
    while viewtk { preprocess_token }
    drop
}

// tok_ptr -- new_tok_ptr
:skip_braces {
    // -- depth tok_ptr
    1 swap while tok_next over {
        if viewtk TOK_BRACE_START == {
            swap 1+ swap
        } else if viewtk TOK_BRACE_END == {
            swap 1- swap
        }
    }
    // -- tok_ptr
    nip
}

// tok_ptr --
:preprocess_macro_block {
    tok_next
    // -- depth tok_ptr
    1 swap while over {
        if viewtk TOK_BRACE_START == {
            swap 1+ swap
        } else if viewtk TOK_BRACE_END == {
            swap 1- swap
        }
        if over {
            preprocess_token
        }
    }
    tok_next
    drop drop
}

// token_kind -- bool
:is_tagged_ident {
    // token_kind
    dup (TOK_REF ==) swap
    dup (TOK_FN ==) swap
    dup (TOK_EQ ==) swap
    dup (TOK_FIELD ==) swap
    (TOK_SIZE ==)
    | | | |
}
// token_kind -- bool
:is_macro_replaceable {
    // token_kind
    dup (TOK_IDENT ==) swap
    dup (TOK_WORD ==) swap
    is_tagged_ident
    | |
}

// tok_ptr -- new_tok_ptr
:preprocess_word {
    $static char arg_kind
    viewtk =arg_kind

    // -- name tok_ptr
    viewtd swap
    // -- name tok_ptr def_tok_ptr
    if over &macros_map map_get dup {
        swap tok_next swap
        // Arguments (optional)
        if viewtk TOK_PAREN_START == {
            // -- name def_tok_ptr tok_ptr
            swap
            if viewtk TOK_PAREN_START != {
                "ERROR: Expected arguments for macro '"eputs 2 pick eputs "'\n"eputs
                1 exit
            }
            tok_next

            // -- name tok_ptr def_tok_ptr
            while swap tok_next viewtk TOK_PAREN_END != {
                // -- name tok_ptr def_tok_ptr
                // TODO: prevent name collision between macros and macro arguments
                viewtd 2 pick &macros_map map_insert

                // -- name def_tok_ptr tok_ptr
                swap
                if viewtk TOK_BRACE_START == {
                    skip_braces
                } else if viewtk TOK_PAREN_END == {
                    "ERROR: Invalid number of arguments supplied to macro '"eputs 2 pick eputs "'\n"eputs
                    1 exit
                } else {
                    tok_next
                }
            }
            // -- name def_tok_ptr tok_ptr
            tok_next swap
            if viewtk TOK_PAREN_END != {
                "ERROR: Invalid number of arguments supplied to macro '"eputs 2 pick eputs "'\n"eputs
                1 exit
            }
            // -- name tok_ptr def_tok_ptr
            tok_next swap
        }
        if viewtk TOK_BRACE_START == {
            // -- tok_ptr def_tok_ptr
            rot drop
            preprocess_macro_block
        } else {
            if arg_kind is_tagged_ident {
                if viewtk TOK_IDENT != {
                    "ERROR: Macro expansion for '"eputs 2 pick eputs "' expected ident, found tagged ident\n"eputs
                    1 exit
                }
                arg_kind over!c
            }
            preprocess_token
            drop nip
        }
    } else {
        // -- tok_ptr
        drop nip
        viewtk swap viewtd rot &out_toks_mem toks_push
        tok_next
    }
}

// tok_ptr -- new_tok_ptr
:preprocess_include {
    tok_next
    if viewtk TOK_STR != {
        "ERROR: Expected file name after 'include' directive\n"eputs
        1 exit
    }

    // Check if this file has already been included
    if viewtd &files_set set_contains {
        tok_next
        return
    }
    viewtd &files_set set_insert

    // -- tok_ptr fd
    if viewtd 0 fopen dup is_failure {
        "ERROR: 'include' directive failed to open file '"eputs swap viewtd eputs "'\n"eputs
        1 exit
    }
    // -- tok_ptr fd bytes_read
    if &src_str SRC_STR_SIZE 2 pick fread dup is_failure {
        "ERROR: 'include' directive failed to read file '"eputs swap viewtd eputs "'\n"eputs
        1 exit
    }
    // -- tok_ptr fd
    &src_str + 0 swap !c

    // -- tok_ptr
    if fclose is_failure {
        "ERROR: 'include' directive failed to close file '"eputs swap viewtd eputs "'\n"eputs
        1 exit
    }

    // -- tok_ptr include_tok_ptr
    &toks_mem toks_top
    &src_str lex_src

    preprocess
    tok_next
}

// tok_ptr -- new_tok_ptr
:preprocess_macro_def {
    if viewtd &macros_map map_get {
        "ERROR: Macro '"eputs viewtd eputs "' already defined\n"eputs
        1 exit
    }
    // -- name tok_ptr
    viewtd swap tok_next
    over over &macros_map map_insert

    // Arguments (optional)
    // -- name tok_ptr
    if viewtk TOK_PAREN_START == {
        while tok_next viewtk TOK_PAREN_END != {
            if viewtk TOK_IDENT != {
                "ERROR: Invalid parameter in definition for macro '"eputs over eputs "'\n"eputs
                1 exit
            }
        }
        tok_next
    }

    if viewtk TOK_BRACE_START != {
        "ERROR: Invalid body for macro '"eputs over eputs "'\n"eputs
        1 exit
    }
    // -- tok_ptr
    nip
    skip_braces
}

// tok_ptr -- new_tok_ptr
:preprocess_pound {
    tok_next
    if check_include {
        preprocess_include
    } else if viewtk dup (TOK_IDENT ==) swap (TOK_WORD ==) | {
        preprocess_macro_def
    } else {
        "ERROR: Unexpected preprocessor directive\n"eputs
        1 exit
    }
}

// tok_ptr -- new_tok_ptr
:preprocess_token {
    if viewtk is_macro_replaceable {
        preprocess_word
    } else if viewtk TOK_POUND == {
        preprocess_pound
    } else {
        viewtk swap viewtd rot &out_toks_mem toks_push
        tok_next
    }
}

:preprocess_src {
    &toks_mem tok_first preprocess
    0 TOK_EOF &out_toks_mem toks_push
}