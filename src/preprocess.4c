#use "config.4c"
#use "token.4c"
#use "map.4c"

// tok_ptr -- new_tok_ptr
:preprocess_token

// tok_ptr --
:preprocess {
    while viewtk { preprocess_token }
    drop
}

#macro skip_delim(start, end) {
    // -- depth tok_ptr
    1 swap while %Token+ over {
        if viewtk TKind.start == {
            swap 1+ swap
        } else if viewtk TKind.end == {
            swap 1- swap
        }
    }
    // -- tok_ptr
    nip
}

// tok_ptr -- new_tok_ptr
:skip_braces {
    skip_delim(BRACE_START, BRACE_END)
}
// tok_ptr -- new_tok_ptr
:skip_paren {
    skip_delim(PAREN_START, PAREN_END)
}

// tok_ptr -- tok_ptr
#macro preprocess_delim(start, end) {
    %Token+
    // -- depth tok_ptr
    1 swap while over {
        if viewtk TKind.start == {
            swap 1+ swap
        } else if viewtk TKind.end == {
            swap 1- swap
        }
        if over {
            preprocess_token
        }
    }
    nip %Token+
}

// tok_ptr -- tok_ptr
:preprocess_brace_block {
    preprocess_delim(BRACE_START, BRACE_END)
}

// tok_ptr -- tok_ptr
:preprocess_paren_block {
    preprocess_delim(PAREN_START, PAREN_END)
}

// name tok_ptr macro_idx -- new_tok_ptr
:preprocess_macro_call {
    $bool is_arg: {dup MACRO_MAP map_idx->Macro.is_arg@c}
    $ptr src: {over}

    if 2 pick "HERE_FILE" streq {
        src->Token.file@ TKind.STR src->Token.file@ src->Token.line@ &out_toks_mem tok_push
        drop nip %Token+ return
    } else if 2 pick "HERE_LINE" streq {
        src->Token.line@ TKind.INT src->Token.file@ src->Token.line@ &out_toks_mem tok_push
        drop nip %Token+ return
    }

    // name tok_ptr macro_def
    MACRO_MAP map_idx->Macro.toks@
    if dup not {
        drop
        error "Attempted to expand preprocessor flag '"puts swap puts "'\n"puts
        1 exit
    }

    if is_arg {
        $int counter: {0}
        while (viewtk dup (TKind.COMMA !=) swap (TKind.PAREN_END !=) &) (counter) | {
            if viewtk TKind.PAREN_START == { 1 +=counter }
            else if viewtk TKind.PAREN_END == { 1 -=counter }
            preprocess_token
        }
        drop nip
        %Token+
        return
    }

    dup SCOPE_STACK stack_push!
    swap %Token+ swap
    // Arguments (optional)
    if viewtk TKind.PAREN_START == {
        // -- name def_tok_ptr tok_ptr
        swap
        if viewtk TKind.PAREN_START != {
            error "Expected arguments for macro '"puts 2 pick puts "'\n"puts
            1 exit
        }
        // -- name tok_ptr def_tok_ptr
        %Token+ swap %Token+

        // -- name tok_ptr def_tok_ptr
        while viewtk TKind.PAREN_END != {
            $bool had_comma
            // -- name tok_ptr def_tok_ptr slot_ptr
            viewtd SCOPE_STACK stack_last@ MACRO_MAP scoped_map_get
            over->Token.data@ over->Macro.key.name!
            true over->Macro.is_arg!c
            SCOPE_STACK stack_last@ over->Macro.key.scope!
            2 pick swap->Macro.toks!
            // -- name def_tok_ptr tok_ptr
            swap
            if (viewtk TKind.PAREN_END ==) (had_comma not) & {
                error "Invalid number of arguments supplied to macro '"puts 2 pick puts "'\n"puts
                1 exit
            } else {
                while viewtk dup (TKind.COMMA !=) swap (TKind.PAREN_END !=) & {
                    if viewtk TKind.BRACE_START == { skip_braces }
                    else if viewtk TKind.PAREN_START == { skip_paren }
                    else { %Token+ }
                }
                if viewtk TKind.COMMA == dup =had_comma { %Token+ }
            }
            swap %Token+
            if viewtk TKind.COMMA == { %Token+ }
        }

        // -- name def_tok_ptr tok_ptr
        %Token+ swap
        if viewtk TKind.PAREN_END != {
            error "Invalid number of arguments supplied to macro '"puts 2 pick puts "'\n"puts
            1 exit
        }
        // -- name tok_ptr def_tok_ptr
        %Token+ swap
    }
    if viewtk TKind.BRACE_START == {
        // -- tok_ptr def_tok_ptr
        rot drop
        preprocess_brace_block drop
    }
    &scope_stack stack_shrink
}

// tok_ptr -- new_tok_ptr
:preprocess_word {
    $char arg_kind: {viewtk}

    // -- name tok_ptr
    viewtd swap
    // -- name tok_ptr macro_idx
    if over MACRO_MAP scoped_map_find_idx dup is_success {
        preprocess_macro_call
    } else {
        // -- tok_ptr
        drop nip
        dup &out_toks_mem tok_push_clone
        %Token+
    }
}

// path -- name
:_file_name {
    $ptr name: {}
    name while dup@c {
        if dup@c '/' == {
            dup 1+ =name
        }
        %char+
    } drop
    name
}

// name -- file_path fd
:_open_file {
    $ptr name: {}
    $int idx: {0}
    while idx &dirs_mem stack_len < {
        $char[256] file_path
        idx DIRS_MEM stack_get@ &file_path strcpy
        name &file_path strcat

        $ptr fd: {&file_path 0 fopen}
        if fd is_success {
            &file_path fd return
        }

        1 +=idx
    }
    NULL -1 return
}

// name --
:pub use_file {
    $ptr name: {}
    if name _file_name FILE_SET map_contains {
        return
    }

    name _open_file
    $ptr fd: {}
    $ptr path: {}

    if fd is_failure {
        error "'use' directive failed to open file '"puts name puts "'\n"puts
        1 exit
    }
    name _file_name dup FILE_SET map_get!

    $int read_res: {&src_str SRC_STR_SIZE fd fread }
    if read_res is_failure {
        error "'use' directive failed to read file '"puts path puts "'\n"puts
        1 exit
    }
    0 (read_res &src_str+)!c

    if fd fclose is_failure {
        error "'use' directive failed to close file '"puts path puts "'\n"puts
        1 exit
    }

    dup SCOPE_STACK stack_push!
    // -- tok_ptr use_tok_ptr
    &toks_mem %Token stack_top
    &src_str name lex_src
    0 TKind.FILE_START name 0 &out_toks_mem tok_push
    preprocess
    0 TKind.FILE_END name 0 &out_toks_mem tok_push
    &scope_stack stack_shrink
}

// tok_ptr -- new_tok_ptr
:parse_use_directive {
    %Token+
    if viewtk TKind.STR != {
        error "Expected file name for 'use' directive\n"puts
        1 exit
    }
    viewtd use_file %Token+
}

// tok_ptr -- new_tok_ptr
:parse_error_directive {
    %Token+
    if viewtk TKind.STR == {
        error viewtd puts
    } else {
        error "Expected message for 'error' directive\n"puts
    }
    1 exit
}

// tok_ptr -- new_tok_ptr
:parse_macro_directive {
    %Token+
    if viewtk dup (TKind.IDENT !=) swap (TKind.WORD !=) & {
        error "Expected name for 'macro' directive\n"puts
        1 exit
    }
    if viewtd SCOPE_STACK stack_last@ MACRO_MAP scoped_map_contains {
        error "Macro '"puts viewtd puts "' already defined in this scope\n"puts
        1 exit
    }
    // -- name tok_ptr
    viewtd swap %Token+
    $int scope: {if IS_PUBLIC { NULL } else { SCOPE_STACK stack_last@ }}

    // -- name tok_ptr slot_ptr
    over scope MACRO_MAP scoped_map_get
    over over->Macro.toks!
    false over->Macro.is_arg!c
    scope over->Macro.key.scope!
    2 pick swap->Macro.key.name!

    // Arguments (optional)
    // -- name tok_ptr
    if viewtk TKind.PAREN_START == {
        %Token+
        while viewtk TKind.PAREN_END != {
            if viewtk TKind.IDENT != {
                error "Invalid parameter in definition for macro '"puts over puts "'\n"puts
                1 exit
            }
            if %Token+ viewtk TKind.PAREN_END != {
                if viewtk TKind.COMMA != {
                    error "Expected comma after parameter in definition for macro '"puts over puts "'\n"puts
                    1 exit
                }
                %Token+
            }
        }
        %Token+
    }

    if viewtk TKind.BRACE_START != {
        error "Invalid body for macro '"puts over puts "'\n"puts
        1 exit
    }
    // -- tok_ptr
    nip skip_braces
}

// tok_ptr -- new_tok_ptr
:parse_flag_directive {
    %Token+
    if viewtk TKind.IDENT != {
        error "Expected identifier for 'flag' directive\n"puts
        1 exit
    }
    if viewtd SCOPE_STACK stack_last@ MACRO_MAP scoped_map_contains {
        error "Macro '"puts viewtd puts "' already defined in this scope\n"puts
        1 exit
    }

    $int scope: {if IS_PUBLIC { NULL } else { SCOPE_STACK stack_last@ }}
    viewtd
    dup scope MACRO_MAP scoped_map_get
    swap over->Macro.key.name!
    scope over->Macro.key.scope!
    NULL swap->Macro.toks!
    %Token+
}

// tok_ptr -- new_tok_ptr
:parse_undef_directive {
    %Token+
    if viewtk dup (TKind.IDENT !=) swap (TKind.WORD !=) & {
        error "Expected macro name for 'undef' directive\n"puts
        1 exit
    }
    if viewtd MACRO_MAP scoped_map_find_idx is_failure {
        error "Macro '"puts viewtd puts "' not defined\n"puts
        1 exit
    }

    viewtd MACRO_MAP scoped_map_find_idx MACRO_MAP map_idx
    NULL over->Macro.key.name!
    NULL over->Macro.key.scope!
    NULL swap->Macro.toks!
    %Token+
}

// tok_ptr -- new_tok_ptr
#macro parse_if_directive(true_case, false_case) {
    %Token+
    if viewtk dup (TKind.IDENT !=) swap (TKind.WORD !=) & {
        error "Expected macro name for 'if' directive\n"puts
        1 exit
    }

    // -- macro_name tok_ptr
    viewtd swap %Token+
    if viewtk TKind.BRACE_START != {
        error "Expected braces for 'if' directive\n"puts
        1 exit
    }

    if swap MACRO_MAP scoped_map_find_idx is_success {
        true_case
    } else {
        false_case
    }
}

// tok_ptr -- new_tok_ptr
:preprocess_pound {
    %Token+
    if viewtk TKind.PUB == {
        true =IS_PUBLIC
        %Token+
        if viewtd "macro" streq { parse_macro_directive }
        else if viewtd "flag" streq { parse_flag_directive }
        else {
            error "Unknown preprocessor directive '"puts viewtd puts "' following 'pub'\n"puts
            1 exit
        }
        false =IS_PUBLIC
        return
    }

    if viewtk TKind.IDENT != {
        error "Invalid preprocessor directive\n"puts
        1 exit
    }
    if viewtd "use" streq { parse_use_directive }
    else if viewtd "error" streq { parse_error_directive }
    else if viewtd "macro" streq { parse_macro_directive }
    else if viewtd "flag" streq { parse_flag_directive }
    else if viewtd "undef" streq { parse_undef_directive }
    else if viewtd "ifdef" streq { parse_if_directive(preprocess_brace_block, skip_braces) }
    else if viewtd "ifndef" streq { parse_if_directive(skip_braces, preprocess_brace_block) }
    else {
        error "Unknown preprocessor directive '"puts viewtd puts "'\n"puts
        1 exit
    }
}

// tok_ptr -- new_tok_ptr
:preprocess_token {
    if viewtk dup (TKind.IDENT ==) swap (TKind.WORD ==) | {
        preprocess_word
    } else if viewtk TKind.POUND == {
        preprocess_pound
    } else {
        if viewtk TKind.BRACE_START == {
            dup SCOPE_STACK stack_push!
        } else if viewtk TKind.BRACE_END == {
            &scope_stack stack_shrink
        }
        dup &out_toks_mem tok_push_clone
        %Token+
    }
}

:pub preprocess_src {
    &toks_mem->StackHead.data preprocess
    0 TKind.EOF NULL 0 &out_toks_mem tok_push
}

// name --
:pub define_builtin_flag {
    dup SCOPE_STACK stack_last@ MACRO_MAP scoped_map_get
    NULL over->Macro.toks!
    NULL over->Macro.key.scope!
    ->Macro.key.name!
}

// name -- bool
:pub has_builtin_flag {
    MACRO_MAP scoped_map_find_idx is_success
}