#use "config.4c"
#use "token.4c"
#use "map.4c"

static ptr expansion_origin
static ptr expansion_depth
static int scope_depth

// tok_ptr -- new_tok_ptr
:preprocess_token

// tok_ptr --
:preprocess {
    while viewtk { preprocess_token }
    drop
}

// tok_ptr -- tok_ptr
#macro preprocess_delim(start, end) {
    %Token+
    // -- depth tok_ptr
    1 swap while over {
        if viewtk TKind.start == {
            swap 1+ swap
        } else if viewtk TKind.end == {
            swap 1- swap
        }
        if over {
            preprocess_token
        }
    }
    nip %Token+
}

// tok_ptr -- tok_ptr
:preprocess_brace_block {
    preprocess_delim(BRACE_START, BRACE_END)
}

// tok_ptr -- tok_ptr
:preprocess_paren_block {
    preprocess_delim(PAREN_START, PAREN_END)
}

// name tok_ptr macro_idx -- new_tok_ptr
:preprocess_macro_call {
    dup MACRO_MAP map_idx
    $int n_args: {dup->Macro.n_args@}
    $bool is_arg: {->Macro.is_arg@c}
    $ptr src: {over}

    #macro parse_here_macro(name, access, tkind) {
        if 2 pick name strcmp not {
            src->Token.access@ TKind.tkind src->Token.file@ src->Token.line@ &out_toks_mem tok_push
            drop nip %Token+ return
        }
    }
    parse_here_macro("HERE_FILE", file, STR)
    parse_here_macro("HERE_LINE", line, INT)

    // name tok_ptr macro_def
    MACRO_MAP map_idx->Macro.toks@
    if dup not {
        drop
        error "Attempted to expand preprocessor flag '"puts swap puts "'\n"puts
        1 exit
    }

    if expansion_depth not {
        over =expansion_origin
    }

    1 +=expansion_depth
    if expansion_depth MACRO_DEPTH_LIMIT > {
        error "Macro expansion cannot exceed depth "puts MACRO_DEPTH_LIMIT put "\n"puts
        1 exit
    }

    if is_arg {
        $int counter: {0}
        while (viewtk dup (TKind.COMMA !=) swap (TKind.PAREN_END !=) &) (counter) | {
            if viewtk TKind.PAREN_START == { 1 +=counter }
            else if viewtk TKind.PAREN_END == { 1 -=counter }
            preprocess_token
        }
        drop nip
        %Token+
        1 -=expansion_depth
        return
    }

    dup SCOPE_STACK stack_push!
    swap %Token+ swap

    // Arguments (optional)
    if viewtk TKind.PAREN_START == {
        // -- name def_tok_ptr tok_ptr
        swap
        if viewtk TKind.PAREN_START != {
            error "Expected arguments for macro '"puts 2 pick puts "'\n"puts
            1 exit
        }
        // -- name tok_ptr def_tok_ptr
        %Token+ swap %Token+

        // -- name tok_ptr def_tok_ptr
        while viewtk TKind.PAREN_END != {
            // -- name tok_ptr def_tok_ptr slot_ptr
            viewtd SCOPE_STACK stack_last@ MACRO_MAP scoped_map_get
            over->Token.data@ over->Macro.key.name!
            SCOPE_STACK stack_last@ over->Macro.key.scope!
            0 over->Macro.n_args!
            2 pick over->Macro.toks!
            true swap->Macro.is_arg!c

            // -- name def_tok_ptr tok_ptr
            swap
            if viewtk TKind.PAREN_END == {
                if dup %Token- ->Token.kind TKind.COMMA == {
                    error "Invalid number of arguments supplied to macro '"puts 2 pick puts "'\n"puts
                    1 exit
                }
                swap %Token+
                break
            }

            $char parse_until_tok: { if n_args 1 > {TKind.COMMA} else {TKind.PAREN_END} }
            $char err_if_tok: { if n_args 1 > {TKind.PAREN_END} else {TKind.COMMA} }
            while viewtk parse_until_tok != {
                if viewtk err_if_tok == {
                    error "Invalid number of arguments supplied to macro '"puts 2 pick puts "'\n"puts
                    1 exit
                }
                if viewtk TKind.BRACE_START == { skip_braces }
                else if viewtk TKind.PAREN_START == { skip_paren }
                else if viewtk TKind.BRACKET_START == { skip_brackets }
                else { %Token+ }
            }
            1 -=n_args
            if viewtk TKind.COMMA == { %Token+ }

            swap %Token+
            if viewtk TKind.COMMA == { %Token+ }
        }

        // -- name def_tok_ptr tok_ptr
        %Token+ swap
        if viewtk TKind.PAREN_END != {
            error "Invalid number of arguments supplied to macro '"puts 2 pick puts "'\n"puts
            1 exit
        }
        // -- name tok_ptr def_tok_ptr
        %Token+ swap
    }

    if viewtk TKind.BRACE_START == {
        // -- tok_ptr def_tok_ptr
        rot drop
        preprocess_brace_block drop
    }
    &scope_stack stack_shrink
    1 -=expansion_depth
}

// tok_ptr -- new_tok_ptr
:preprocess_word {
    $char arg_kind: {viewtk}

    // -- name tok_ptr
    viewtd swap
    // -- name tok_ptr macro_idx
    if over MACRO_MAP scoped_map_find_idx dup is_success {
        preprocess_macro_call
    } else {
        // -- tok_ptr
        drop nip
        dup &out_toks_mem tok_push_clone
        %Token+
    }
}

// file_path --
pub :add_file_dir {
    $ptr name: {}
    $int n: {0}
    $int size: {0}

    while $char c: {name n+ @c} c {
        1 +=n
        if c '/' == { n =size }
    }

    $ptr dir_ptr: {STRS_MEM stack_top}

    name dir_ptr size strncpy
    &strs_mem stack_len size+ &strs_mem!
    0 STRS_MEM stack_push!c

    for $int i: {0}, i &dirs_mem stack_len <, 1 +=i {
        if (i DIRS_MEM stack_get@) (dir_ptr) strcmp not {
            return
        }
    }
    dir_ptr DIRS_MEM stack_push!
}

// name -- file_path fd
:_open_file {
    $ptr name: {}
    $int idx: {0}
    while idx &dirs_mem stack_len < {
        $char[256] file_path
        idx DIRS_MEM stack_get@ &file_path strcpy
        name &file_path strcat

        $ptr fd: {&file_path 0 fopen}
        if fd is_success {
            &file_path add_file_dir

            $ptr path: {STRS_MEM stack_top}
            &file_path path strcpy
            (&strs_mem stack_len) (&file_path strlen)+ &strs_mem!
            0 STRS_MEM stack_push!c

            path fd return
        }

        1 +=idx
    }
    NULL -1 return
}

// name -- result
pub :use_file {
    $ptr name: {}

    name _open_file
    $ptr fd: {}
    $ptr path: {}

    if path FILE_SET map_contains {
        if fd fclose is_failure {
            "WARNING: 'use' directive failed to close file '"puts path puts "'\n"puts
            -1 return
        }
        0 return
    }

    if fd is_failure {
        "WARNING: 'use' directive failed to open file '"puts name puts "'\n"puts
        -1 return
    }
    path dup FILE_SET map_get!

    $int read_res: {&src_str SRC_STR_SIZE fd fread }
    if read_res is_failure {
        "WARNING: 'use' directive failed to read file '"puts path puts "'\n"puts
        -1 return
    }
    0 (read_res &src_str+)!c

    if fd fclose is_failure {
        "WARNING: 'use' directive failed to close file '"puts path puts "'\n"puts
        -1 return
    }

    dup SCOPE_STACK stack_push!
    // -- tok_ptr use_tok_ptr
    &toks_mem %Token stack_top
    &src_str name lex_src
    0 TKind.FILE_START name 0 &out_toks_mem tok_push
    preprocess
    0 TKind.FILE_END name 0 &out_toks_mem tok_push
    &scope_stack stack_shrink

    0 return
}

// tok_ptr -- new_tok_ptr
:parse_use_directive {
    %Token+
    if viewtk TKind.STR != {
        error "Expected file name for 'use' directive\n"puts
        1 exit
    }
    if viewtd "./" strstr {
        error "File paths must not contain './'\n"puts
        1 exit
    }
    if viewtd "../" strstr {
        error "File paths must not contain '../'\n"puts
        1 exit
    }
    if viewtd use_file is_failure {
        error "Failed to use file '"puts viewtd puts "'\n"puts
        1 exit
    }
    %Token+
}

// tok_ptr -- new_tok_ptr
:parse_fail_directive {
    %Token+
    if viewtk TKind.STR == {
        error viewtd puts
    } else {
        error "Expected message for 'fail' directive\n"puts
    }
    1 exit
}

// tok_ptr -- new_tok_ptr
:parse_raise_directive {
    %Token+
    if viewtk TKind.STR == {
        if expansion_depth {
            expansion_origin
            error drop
        } else {
            error
        }
        viewtd puts
    } else {
        error "Expected message for 'raise' directive\n"puts
    }
    1 exit
}

// tok_ptr -- new_tok_ptr
:parse_macro_directive {
    %Token+
    if viewtk dup (TKind.IDENT !=) swap (TKind.WORD !=) & {
        error "Expected name for 'macro' directive\n"puts
        1 exit
    }
    if viewtd SCOPE_STACK stack_last@ MACRO_MAP scoped_map_contains {
        error "Macro '"puts viewtd puts "' already defined in this scope\n"puts
        1 exit
    }

    $ptr name: {viewtd} %Token+
    $ptr macro_toks: {dup}
    $int scope: {if IS_PUBLIC { NULL } else { SCOPE_STACK stack_last@ }}

    // Arguments (optional)
    $int n_args: {0}
    if viewtk TKind.PAREN_START == {
        %Token+
        while viewtk TKind.PAREN_END != {
            1 +=n_args
            if viewtk TKind.IDENT != {
                error "Invalid parameter in definition for macro '"puts name puts "'\n"puts
                1 exit
            }
            if %Token+ viewtk TKind.PAREN_END != {
                if viewtk TKind.COMMA != {
                    error "Expected comma after parameter in definition for macro '"puts name puts "'\n"puts
                    1 exit
                }
                %Token+
            }
        }
        %Token+
    }

    name scope MACRO_MAP scoped_map_get
    name over->Macro.key.name!
    scope over->Macro.key.scope!
    n_args over->Macro.n_args!
    macro_toks over->Macro.toks!
    false swap->Macro.is_arg!c

    if viewtk TKind.BRACE_START != {
        error "Invalid body for macro '"puts name puts "'\n"puts
        1 exit
    }
    skip_braces
}

// tok_ptr -- new_tok_ptr
:parse_flag_directive {
    %Token+
    if viewtk TKind.IDENT != {
        error "Expected identifier for 'flag' directive\n"puts
        1 exit
    }
    if viewtd SCOPE_STACK stack_last@ MACRO_MAP scoped_map_contains {
        error "Macro '"puts viewtd puts "' already defined in this scope\n"puts
        1 exit
    }

    $int scope: {if IS_PUBLIC { NULL } else { SCOPE_STACK stack_last@ }}
    viewtd
    dup scope MACRO_MAP scoped_map_get
    swap over->Macro.key.name!
    scope over->Macro.key.scope!
    0 over->Macro.n_args!
    NULL over->Macro.toks!
    false swap->Macro.is_arg!c
    %Token+
}

// tok_ptr -- new_tok_ptr
:parse_undef_directive {
    %Token+
    if viewtk dup (TKind.IDENT !=) swap (TKind.WORD !=) & {
        error "Expected macro name for 'undef' directive\n"puts
        1 exit
    }
    if viewtd MACRO_MAP scoped_map_find_idx is_failure {
        error "Macro '"puts viewtd puts "' not defined\n"puts
        1 exit
    }

    viewtd MACRO_MAP scoped_map_find_idx MACRO_MAP map_idx
    NULL over->Macro.key.name!
    NULL over->Macro.key.scope!
    NULL swap->Macro.toks!
    %Token+
}

// tok_ptr -- new_tok_ptr
#macro parse_if_directive(true_case, false_case) {
    %Token+
    if viewtk dup (TKind.IDENT !=) swap (TKind.WORD !=) & {
        error "Expected macro name for 'if' directive\n"puts
        1 exit
    }

    // -- macro_name tok_ptr
    viewtd swap %Token+
    if viewtk TKind.BRACE_START != {
        error "Expected braces for 'if' directive\n"puts
        1 exit
    }

    if swap MACRO_MAP scoped_map_find_idx is_success {
        true_case
    } else {
        false_case
    }
}

// tok_ptr -- new_tok_ptr
:preprocess_pound {
    %Token+
    if viewtk TKind.PUB == {
        if scope_depth {
            error "Public preprocessor items can only be defined at the global scope\n"puts
            1 exit
        }

        true =IS_PUBLIC
        %Token+
        if viewtd "macro" strcmp not { parse_macro_directive }
        else if viewtd "flag" strcmp not { parse_flag_directive }
        else {
            error "Unknown preprocessor directive '"puts viewtd puts "' following 'pub'\n"puts
            1 exit
        }
        false =IS_PUBLIC
        return
    }

    if viewtk TKind.IDENT != {
        error "Invalid preprocessor directive\n"puts
        1 exit
    }
    if viewtd "use" strcmp not { parse_use_directive }
    else if viewtd "fail" strcmp not { parse_fail_directive }
    else if viewtd "raise" strcmp not { parse_raise_directive }
    else if viewtd "macro" strcmp not { parse_macro_directive }
    else if viewtd "flag" strcmp not { parse_flag_directive }
    else if viewtd "undef" strcmp not { parse_undef_directive }
    else if viewtd "ifdef" strcmp not { parse_if_directive(preprocess_brace_block, skip_braces) }
    else if viewtd "ifndef" strcmp not { parse_if_directive(skip_braces, preprocess_brace_block) }
    else {
        error "Unknown preprocessor directive '"puts viewtd puts "'\n"puts
        1 exit
    }
}

// tok_ptr -- new_tok_ptr
:preprocess_token {
    if viewtk dup (TKind.IDENT ==) swap (TKind.WORD ==) | {
        preprocess_word
    } else if viewtk TKind.POUND == {
        preprocess_pound
    } else {
        if viewtk TKind.BRACE_START == {
            1 +=scope_depth
            dup SCOPE_STACK stack_push!
        } else if viewtk TKind.BRACE_END == {
            1 -=scope_depth
            &scope_stack stack_shrink
        }
        dup &out_toks_mem tok_push_clone
        %Token+
    }
}

pub :preprocess_src {
    0 =scope_depth
    &toks_mem->StackHead.data preprocess
    0 TKind.EOF NULL 0 &out_toks_mem tok_push
}