#use "src/config.4c"
#use "src/token.4c"
#use "src/map.4c"

// tok_ptr -- new_tok_ptr
:preprocess_token

// tok_ptr --
:preprocess {
    while viewtk { preprocess_token }
    drop
}

// tok_ptr -- new_tok_ptr
:skip_braces {
    // -- depth tok_ptr
    1 swap while %Token+ over {
        if viewtk TKind.BRACE_START == {
            swap 1+ swap
        } else if viewtk TKind.BRACE_END == {
            swap 1- swap
        }
    }
    // -- tok_ptr
    nip
}

// tok_ptr -- tok_ptr
:preprocess_block {
    %Token+
    // -- depth tok_ptr
    1 swap while over {
        if viewtk TKind.BRACE_START == {
            swap 1+ swap
        } else if viewtk TKind.BRACE_END == {
            swap 1- swap
        }
        if over {
            preprocess_token
        }
    }
    nip %Token+
}

// name -- [idx, -1]
:scoped_macro_idx {
    $int scope_idx: {&scope_stack stack_len}
    while &scope_idx@-- {
        if dup scope_idx SCOPE_STACK stack_get@ MACRO_MAP scoped_map_contains {
            scope_idx SCOPE_STACK stack_get@ MACRO_MAP scoped_map_get_idx
            return
        }
    }
    drop -1
}

// tok_ptr -- new_tok_ptr
:preprocess_word {
    $char arg_kind: {viewtk}

    // -- name tok_ptr
    viewtd swap
    // -- name tok_ptr macro_idx
    if over scoped_macro_idx dup is_success {
        MACRO_MAP map_idx->Macro.toks@
        if dup not {
            drop
            error "Attempted to expand preprocessor flag '"eputs swap eputs "'\n"eputs
            1 exit
        }

        dup SCOPE_STACK stack_push!
        swap %Token+ swap
        // Arguments (optional)
        if viewtk TKind.PAREN_START == {
            // -- name def_tok_ptr tok_ptr
            swap
            if viewtk TKind.PAREN_START != {
                error "Expected arguments for macro '"eputs 2 pick eputs "'\n"eputs
                1 exit
            }
            %Token+

            // -- name tok_ptr def_tok_ptr
            while swap %Token+ viewtk TKind.PAREN_END != {
                // -- name tok_ptr def_tok_ptr slot_ptr
                viewtd SCOPE_STACK stack_last@ MACRO_MAP scoped_map_get
                over->Token.data@ over->Macro.key.name!
                SCOPE_STACK stack_last@ over->Macro.key.scope!
                2 pick swap->Macro.toks!
                // -- name def_tok_ptr tok_ptr
                swap
                if viewtk TKind.BRACE_START == {
                    skip_braces
                } else if viewtk TKind.PAREN_END == {
                    error "Invalid number of arguments supplied to macro '"eputs 2 pick eputs "'\n"eputs
                    1 exit
                } else {
                    %Token+
                }
            }
            // -- name def_tok_ptr tok_ptr
            %Token+ swap
            if viewtk TKind.PAREN_END != {
                error "Invalid number of arguments supplied to macro '"eputs 2 pick eputs "'\n"eputs
                1 exit
            }
            // -- name tok_ptr def_tok_ptr
            %Token+ swap
        }
        if viewtk TKind.BRACE_START == {
            // -- tok_ptr def_tok_ptr
            rot drop
            preprocess_block drop
        } else {
            preprocess_token
            drop nip
        }
        &scope_stack stack_shrink
    } else {
        // -- tok_ptr
        drop nip
        dup &out_toks_mem tok_dup
        %Token+
    }
}

// tok_ptr -- new_tok_ptr
:parse_use_directive {
    %Token+
    if viewtk TKind.STR != {
        error "Expected file name for 'use' directive\n"eputs
        1 exit
    }

    // Check if this file has already been used
    if viewtd FILE_SET map_contains {
        %Token+
        return
    }
    viewtd dup FILE_SET map_get->File.name!

    // -- tok_ptr fd
    if viewtd 0 fopen dup is_failure {
        drop
        error "'use' directive failed to open file '"eputs swap viewtd eputs "'\n"eputs
        1 exit
    }
    // -- tok_ptr fd bytes_read
    if &src_str SRC_STR_SIZE 2 pick fread dup is_failure {
        drop drop
        error "'use' directive failed to read file '"eputs swap viewtd eputs "'\n"eputs
        1 exit
    }
    // -- tok_ptr fd
    &src_str+ 0 swap!c

    // -- tok_ptr
    if fclose is_failure {
        error "'use' directive failed to close file '"eputs swap viewtd eputs "'\n"eputs
        1 exit
    }

    // -- tok_ptr use_tok_ptr
    &toks_mem %Token stack_top
    over->Token.data@ &src_str swap lex_src

    preprocess
    %Token+
}

// tok_ptr -- new_tok_ptr
:parse_error_directive {
    %Token+
    if viewtk TKind.STR == {
        error viewtd eputs
    } else {
        error "Expected message for 'error' directive\n"eputs
    }
    1 exit
}

// tok_ptr -- new_tok_ptr
:parse_macro_directive {
    %Token+
    if viewtk dup (TKind.IDENT !=) swap (TKind.WORD !=) & {
        error "Expected name for 'macro' directive\n"eputs
        1 exit
    }
    if viewtd SCOPE_STACK stack_last@ MACRO_MAP scoped_map_contains {
        error "Macro '"eputs viewtd eputs "' already defined in this scope\n"eputs
        1 exit
    }
    // -- name tok_ptr
    viewtd swap %Token+
    // -- name tok_ptr slot_ptr
    over SCOPE_STACK stack_last@ MACRO_MAP scoped_map_get
    over over->Macro.toks!
    SCOPE_STACK stack_last@ over->Macro.key.scope!
    2 pick swap->Macro.key.name!

    // Arguments (optional)
    // -- name tok_ptr
    if viewtk TKind.PAREN_START == {
        while %Token+ viewtk TKind.PAREN_END != {
            if viewtk TKind.IDENT != {
                error "Invalid parameter in definition for macro '"eputs over eputs "'\n"eputs
                1 exit
            }
        }
        %Token+
    }

    if viewtk TKind.BRACE_START != {
        error "Invalid body for macro '"eputs over eputs "'\n"eputs
        1 exit
    }
    // -- tok_ptr
    nip
    skip_braces
}

// tok_ptr -- new_tok_ptr
:parse_flag_directive {
    %Token+
    if viewtk TKind.IDENT != {
        error "Expected identifier for 'flag' directive\n"eputs
        1 exit
    }
    if viewtd SCOPE_STACK stack_last@ MACRO_MAP scoped_map_contains {
        error "Macro '"eputs viewtd eputs "' already defined in this scope\n"eputs
        1 exit
    }

    viewtd
    dup SCOPE_STACK stack_last@ MACRO_MAP scoped_map_get
    swap over->Macro.key.name!
    SCOPE_STACK stack_last@ over->Macro.key.scope!
    NULL swap->Macro.toks!
    %Token+
}

// tok_ptr -- new_tok_ptr
:parse_undef_directive {
    %Token+
    if viewtk dup (TKind.IDENT !=) swap (TKind.WORD !=) & {
        error "Expected macro name for 'undef' directive\n"eputs
        1 exit
    }
    if viewtd scoped_macro_idx is_failure {
        error "Macro '"eputs viewtd eputs "' not defined\n"eputs
        1 exit
    }

    viewtd scoped_macro_idx MACRO_MAP map_idx
    NULL over->Macro.key.name!
    NULL over->Macro.key.scope!
    NULL swap->Macro.toks!
    %Token+
}

// tok_ptr -- new_tok_ptr
#macro parse_if_directive(true_case false_case) {
    %Token+
    if viewtk dup (TKind.IDENT !=) swap (TKind.WORD !=) & {
        error "Expected macro name for 'if' directive\n"eputs
        1 exit
    }

    // -- macro_name tok_ptr
    viewtd swap %Token+
    if viewtk TKind.BRACE_START != {
        error "Expected braces for 'if' directive\n"eputs
        1 exit
    }

    if swap scoped_macro_idx is_success {
        true_case
    } else {
        false_case
    }
}

// tok_ptr -- new_tok_ptr
:preprocess_pound {
    %Token+
    if viewtk TKind.IDENT != {
        error "Invalid preprocessor directive\n"eputs
        1 exit
    }

    if viewtd "use" str_eq {
        parse_use_directive
    } else if viewtd "error" str_eq {
        parse_error_directive
    } else if viewtd "macro" str_eq {
        parse_macro_directive
    } else if viewtd "flag" str_eq {
        parse_flag_directive
    } else if viewtd "undef" str_eq {
        parse_undef_directive
    } else if viewtd "ifdef" str_eq {
        parse_if_directive(preprocess_block skip_braces)
    } else if viewtd "ifndef" str_eq {
        parse_if_directive(skip_braces preprocess_block)
    } else {
        error "Unknown preprocessor directive '"eputs viewtd eputs "'\n"eputs
        1 exit
    }
}

// tok_ptr -- new_tok_ptr
:preprocess_token {
    if viewtk dup (TKind.IDENT ==) swap (TKind.WORD ==) | {
        preprocess_word
    } else if viewtk TKind.POUND == {
        preprocess_pound
    } else {
        if viewtk TKind.BRACE_START == {
            dup SCOPE_STACK stack_push!
        } else if viewtk TKind.BRACE_END == {
            &scope_stack stack_shrink
        }
        dup &out_toks_mem tok_dup
        %Token+
    }
}

:preprocess_src {
    &toks_mem->StackHead.data preprocess
    0 TKind.EOF 0 0 &out_toks_mem tok_push
}

// name --
:define_builtin_flag {
    dup SCOPE_STACK stack_last@ MACRO_MAP scoped_map_get
    NULL over->Macro.toks!
    NULL over->Macro.key.scope!
    ->Macro.key.name!
}