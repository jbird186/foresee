#use "stdchar.4c"
#use "types.4c"
#use "stack.4c"

pub enum TKind {
    EOF
    INT
    CHAR
    STR
    IDENT
    WORD
    FN
    IF
    ELSE
    WHILE
    FOR
    CONTINUE
    BREAK
    COLON
    POUND
    COMMA
    STATIC
    VAR
    REF
    EQ
    ENUM
    STRUCT
    AS
    FIELD
    DEREF
    SIZE
    CALL
    PUB
    PAREN_START
    PAREN_END
    BRACE_START
    BRACE_END
    BRACKET_START
    BRACKET_END
    FILE_START
    FILE_END
}

// data kind file line ref --
pub :tok_push {
    var &Token entry: {%Token stack_push}
    =entry->line
    =entry->file
    =entry->kind
    =entry->data
}

// src dest --
pub :tok_push_clone {
    var &Token entry: {%Token stack_push}
    var &Token src: {}
    src->kind =entry->kind
    src->data =entry->data
    src->file =entry->file
    src->line =entry->line
}

pub :viewtk { dup as Token.kind@c }
pub :viewtd { dup as Token.data@ }
pub :viewtf { dup as Token.file@ }
pub :viewtl { dup as Token.line@ }

// tok_ptr -- tok_ptr
pub :show_tok {
    if viewtk TKind.EOF == { "EOF" puts }
    else if viewtk TKind.INT == { viewtd put }
    else if viewtk TKind.CHAR == {
        viewtd
        if dup isprint {
            "'" puts putc "'" puts
        } else {
            "char(" puts put ")" puts
        }
    }
    else if viewtk TKind.STR == {
        "\"" puts
        var &char c: {viewtd}
        while c@c {
            if c@c isprint { c@c putc }
            else if c@c '\0' == { "\\0" puts }     // null
            else if c@c '\t' == { "\\t" puts }     // tab
            else if c@c '\a' == { "\\a" puts }     // bell
            else if c@c '\b' == { "\\b" puts }     // backspace
            else if c@c '\n' == { "\\n" puts }     // newline
            else if c@c '\v' == { "\\v" puts }     // vertical tab
            else if c@c '\f' == { "\\f" puts }     // form feed
            else if c@c '\r' == { "\\r" puts }     // return
            else if c@c '\'' == { "\'" puts }      // single quote
            else if c@c '\"' == { "\\\"" puts }    // double quote
            else if c@c '\\' == { "\\\\" puts }    // backslash
            else { "\\?" puts }
            1 +=c
        }
        "\"" puts
    }
    else if viewtk TKind.IDENT == { viewtd puts }
    else if viewtk TKind.WORD == { viewtd puts }
    else if viewtk TKind.FN == { ":fn" puts }
    else if viewtk TKind.IF == { "if" puts }
    else if viewtk TKind.ELSE == { "else" puts }
    else if viewtk TKind.WHILE == { "while" puts }
    else if viewtk TKind.FOR == { "for" puts }
    else if viewtk TKind.CONTINUE == { "continue" puts }
    else if viewtk TKind.BREAK == { "break" puts }
    else if viewtk TKind.COLON == { ":" puts }
    else if viewtk TKind.POUND == { "#" puts }
    else if viewtk TKind.COMMA == { "," puts }
    else if viewtk TKind.STATIC == { "static" puts }
    else if viewtk TKind.VAR == { "$" puts }
    else if viewtk TKind.REF == { for (var int i: 0, viewtd i >, 1 +=i) { "&" puts } }
    else if viewtk TKind.EQ == { viewtd puts }
    else if viewtk TKind.ENUM == { "enum" puts }
    else if viewtk TKind.STRUCT == { "struct" puts }
    else if viewtk TKind.AS == { "as" puts }
    else if viewtk TKind.FIELD == { "." puts }
    else if viewtk TKind.DEREF == { "->" puts }
    else if viewtk TKind.SIZE == { "%" puts }
    else if viewtk TKind.CALL == { "call" puts }
    else if viewtk TKind.PUB == { "pub" puts }
    else if viewtk TKind.PAREN_START == { "(" puts }
    else if viewtk TKind.PAREN_END == { ")" puts }
    else if viewtk TKind.BRACE_START == { "{" puts }
    else if viewtk TKind.BRACE_END == { "}" puts }
    else if viewtk TKind.BRACKET_START == { "[" puts }
    else if viewtk TKind.BRACKET_END == { "]" puts }
    else if viewtk TKind.FILE_START == { "FILE_START" puts }
    else if viewtk TKind.FILE_END == { "FILE_END" puts }
    else { "TKind(" puts viewtk put ")" puts }
}

// tok_ptr -- tok_ptr
pub :error {
    viewtf puts ":"puts viewtl put ": ERROR: "puts
}

#macro skip_delim(start, end) {(
    var &Token original_tok_ptr: {dup}
    // -- depth tok_ptr
    1 swap while %Token+ over {
        if viewtk not {
            original_tok_ptr error
            "Expected token of type "puts TKind.end put
            " after token of type "puts viewtk put
            "\n"puts
            1 exit
        }
        if viewtk TKind.start == {
            swap 1+ swap
        } else if viewtk TKind.end == {
            swap 1- swap
        }
    }
    // -- tok_ptr
    nip
)}

// tok_ptr -- new_tok_ptr
pub :skip_braces {
    skip_delim(BRACE_START, BRACE_END)
}

// tok_ptr -- new_tok_ptr
pub :skip_paren {
    skip_delim(PAREN_START, PAREN_END)
}

// tok_ptr -- new_tok_ptr
pub :skip_brackets {
    skip_delim(BRACKET_START, BRACKET_END)
}

// tok_ptr -- tok_ptr
#pub macro skip_until(until_tok_kind) {(
    dup
    while viewtk until_tok_kind != {
        if viewtk not {
            swap error
            "Expected token of type "puts until_tok_kind put
            " after token of type "puts viewtk put
            "\n"puts
            1 exit
        }
        else if viewtk TKind.PAREN_START == { skip_paren }
        else if viewtk TKind.BRACE_START == { skip_braces }
        else if viewtk TKind.BRACKET_START == { skip_brackets }
        else { %Token+ }
    }
    nip
    %Token+
)}