#use "stdchar.4c"
#use "types.4c"
#use "stack.4c"

pub enum TKind {
    EOF
    INT
    CHAR
    STR
    IDENT
    WORD
    FN
    IF
    ELSE
    SWITCH
    CASE
    DEFAULT
    WHILE
    FOR
    CONTINUE
    BREAK
    COLON
    POUND
    COMMA
    STATIC
    VAR
    REF
    EQ
    ENUM
    STRUCT
    AS
    FIELD
    DEREF
    SIZE
    CALL
    PUB
    PAREN_START
    PAREN_END
    BRACE_START
    BRACE_END
    BRACKET_START
    BRACKET_END
    FILE_START
    FILE_END
}

// data kind file line ref --
pub :tok_push {
    var &Token entry: {%Token stack_push}
    =entry->line
    =entry->file
    =entry->kind
    =entry->data
}

// src dest --
pub :tok_push_clone {
    var &Token entry: {%Token stack_push}
    var &Token src: {}
    src->kind =entry->kind
    src->data =entry->data
    src->file =entry->file
    src->line =entry->line
}

pub :viewtk { dup as Token.kind@c }
pub :viewtd { dup as Token.data@ }
pub :viewtf { dup as Token.file@ }
pub :viewtl { dup as Token.line@ }

// tok_ptr -- tok_ptr
pub :show_tok {
    switch viewtk {
    case TKind.EOF { "EOF" puts }
    case TKind.INT { viewtd put }
    case TKind.CHAR {
        viewtd
        if dup isprint {
            "'" puts putc "'" puts
        } else {
            "char(" puts put ")" puts
        }
    }
    case TKind.STR {
        "\"" puts
        var &char c: {viewtd}
        while c@c {
            if c@c isprint { c@c putc }
            else if c@c '\0' == { "\\0" puts }     // null
            else if c@c '\a' == { "\\a" puts }     // bell
            else if c@c '\b' == { "\\b" puts }     // backspace
            else if c@c '\t' == { "\\t" puts }     // tab
            else if c@c '\n' == { "\\n" puts }     // newline
            else if c@c '\v' == { "\\v" puts }     // vertical tab
            else if c@c '\f' == { "\\f" puts }     // form feed
            else if c@c '\r' == { "\\r" puts }     // return
            else if c@c '\'' == { "\'" puts }      // single quote
            else if c@c '\"' == { "\\\"" puts }    // double quote
            else if c@c '\\' == { "\\\\" puts }    // backslash
            else { "\\?" puts }
            1 +=c
        }
        "\"" puts
    }
    case TKind.IDENT { viewtd puts }
    case TKind.WORD { viewtd puts }
    case TKind.FN { ":fn" puts }
    case TKind.IF { "if" puts }
    case TKind.ELSE { "else" puts }
    case TKind.SWITCH { "switch" puts }
    case TKind.DEFAULT { "default" puts }
    case TKind.CASE { "case" puts }
    case TKind.WHILE { "while" puts }
    case TKind.FOR { "for" puts }
    case TKind.CONTINUE { "continue" puts }
    case TKind.BREAK { "break" puts }
    case TKind.COLON { ":" puts }
    case TKind.POUND { "#" puts }
    case TKind.COMMA { "," puts }
    case TKind.STATIC { "static" puts }
    case TKind.VAR { "var" puts }
    case TKind.REF { for (var int i: 0, viewtd i >, 1 +=i) { "&" puts } }
    case TKind.EQ { viewtd puts }
    case TKind.ENUM { "enum" puts }
    case TKind.STRUCT { "struct" puts }
    case TKind.AS { "as" puts }
    case TKind.FIELD { "." puts }
    case TKind.DEREF { "->" puts }
    case TKind.SIZE { "%" puts }
    case TKind.CALL { "call" puts }
    case TKind.PUB { "pub" puts }
    case TKind.PAREN_START { "(" puts }
    case TKind.PAREN_END { ")" puts }
    case TKind.BRACE_START { "{" puts }
    case TKind.BRACE_END { "}" puts }
    case TKind.BRACKET_START { "[" puts }
    case TKind.BRACKET_END { "]" puts }
    case TKind.FILE_START { "FILE_START" puts }
    case TKind.FILE_END { "FILE_END" puts }
    default { "TKind(" puts viewtk put ")" puts }
    }
}

// tok_ptr -- tok_ptr
pub :error {
    viewtf puts ":"puts viewtl put ": ERROR: "puts
}

#macro skip_delim(start, end) {(
    var &Token original_tok_ptr: {dup}
    // -- depth tok_ptr
    1 swap while %Token+ over {
        if viewtk not {
            original_tok_ptr error
            "Expected token of type "puts TKind.end put
            " after token of type "puts viewtk put
            "\n"puts
            1 exit
        }
        if viewtk TKind.start == {
            swap 1+ swap
        } else if viewtk TKind.end == {
            swap 1- swap
        }
    }
    // -- tok_ptr
    nip
)}

// tok_ptr -- new_tok_ptr
pub :skip_braces {
    skip_delim(BRACE_START, BRACE_END)
}

// tok_ptr -- new_tok_ptr
pub :skip_paren {
    skip_delim(PAREN_START, PAREN_END)
}

// tok_ptr -- new_tok_ptr
pub :skip_brackets {
    skip_delim(BRACKET_START, BRACKET_END)
}

// tok_ptr -- tok_ptr
#pub macro skip_until(until_tok_kind) {(
    dup
    while viewtk until_tok_kind != {
        if viewtk not {
            swap error
            "Expected token of type "puts until_tok_kind put
            " after token of type "puts viewtk put
            "\n"puts
            1 exit
        }
        else if viewtk TKind.PAREN_START == { skip_paren }
        else if viewtk TKind.BRACE_START == { skip_braces }
        else if viewtk TKind.BRACKET_START == { skip_brackets }
        else { %Token+ }
    }
    nip
    %Token+
)}