#use "x86_64_nasm_common.4c"

// op_ptr -- new_op_ptr
:compile_op {
    if viewok OKind.EXIT == {
        "    ; OP_EXIT\n"coms_dbg
        "rdi" x64n_compile_pop
        "    mov     eax, 60\n"coms
        "    syscall\n"coms
    }
    else if viewok OKind.FOPEN == {
        "    ; OP_FOPEN\n"coms_dbg
        "rax" x64n_compile_pop           // mode (0 = read, 1 = write, 2 = append)
        "rsi" x64n_compile_pop           // filename pointer
        x64n_flush_push_cache
        "    cmp     rax, 0\n"coms
        "    je      .frl_"coms viewod com "\n"coms
        "    cmp     rax, 1\n"coms
        "    je      .fwl_"coms viewod com "\n"coms
        "    cmp     rax, 2\n"coms
        "    je      .fal_"coms viewod com "\n"coms
        "    jmp     .ffl_"coms viewod com "\n"coms
        "    .frl_"coms viewod com ":\n"coms
        "    mov     rdx, 0\n"coms
        "    jmp     .fdl_"coms viewod com "\n"coms
        "    .fwl_"coms viewod com ":\n"coms
        "    mov     rdx, 577\n"coms
        "    jmp     .fdl_"coms viewod com "\n"coms
        "    .fal_"coms viewod com ":\n"coms
        "    mov     rdx, 1089\n"coms
        "    jmp     .fdl_"coms viewod com "\n"coms
        "    .fdl_"coms viewod com ":\n"coms
        "    mov     rax, 257\n"coms
        "    mov     rdi, -100\n"coms
        "    mov     r10, 420\n"coms
        "    syscall\n"coms
        "rax" x64n_force_compile_push    // push FD (or -1 on error)
        x64n_flush_stack_ptr_delta
        "    jmp     .fel_"coms viewod com "\n"coms
        "    .ffl_"coms viewod com ":\n"coms
        "    mov     rax, -1\n"coms
        "rax" x64n_force_compile_push
        x64n_flush_stack_ptr_delta
        "    .fel_"coms viewod com ":\n"coms
    }
    else if viewok OKind.FREAD == {
        "    ; OP_FREAD\n"coms_dbg
        "rdi" x64n_compile_pop      // file descriptor
        "rdx" x64n_compile_pop      // length
        "rsi" x64n_compile_pop      // buffer pointer
        x64n_flush_push_cache
        "    mov     rax, 0\n"coms  // sys_read
        "    syscall\n"coms
        "rax" x64n_compile_push     // bytes read or -1
    }
    else if viewok OKind.FWRITE == {
        "    ; OP_FWRITE\n"coms_dbg
        "rdi" x64n_compile_pop      // file descriptor
        "rdx" x64n_compile_pop      // length
        "rsi" x64n_compile_pop      // buffer pointer
        x64n_flush_push_cache
        "    mov     rax, 1\n"coms  // sys_write
        "    syscall\n"coms
        "rax" x64n_compile_push          // bytes written or -1
    }
    else if viewok OKind.FCLOSE == {
        "    ; OP_FCLOSE\n"coms_dbg
        "rdi" x64n_compile_pop      // file descriptor
        x64n_flush_push_cache
        "    mov     rax, 3\n"coms  // sys_close
        "    syscall\n"coms
        "rax" x64n_compile_push     // 0 or -1
    }
    else if viewok OKind.GETCWD == {
        "    ; OP_GETCWD\n"coms_dbg
        "rsi" x64n_compile_pop      // length
        "rdi" x64n_compile_pop      // buffer pointer
        x64n_flush_push_cache
        "    mov     rax, 79\n"coms // sys_getcwd
        "    syscall\n"coms
        "rax" x64n_compile_push     // bytes written or error
    }
    // Linux Only
    else if viewok OKind.LIN_syscall == {
        "    ; LIN_syscall\n"coms_dbg
        "rax" x64n_compile_pop   // syscall number
        "r9" x64n_compile_pop    // arg 6
        "r8" x64n_compile_pop    // arg 5
        "r10" x64n_compile_pop   // arg 4
        "rdx" x64n_compile_pop   // arg 3
        "rsi" x64n_compile_pop   // arg 2
        "rdi" x64n_compile_pop   // arg 1
        x64n_flush_push_cache
        "    syscall\n"coms
        "rax" x64n_compile_push  // return value
    }
    else { x64n_compile_generic_op }
    %Op+
}

x64n_compile_text_fns

:text_x86_64_linux_nasm_generic {
    compile_functions

    "; start\n"coms_dbg
    "_start:\n"coms
    "    lea     r12, [bsp + "coms ASM_STACK_SIZE com "]\n"coms
    "    lea     rax, [rsp + 8]\n"coms
    "rax" x64n_force_compile_push
    "    mov     rax, [rsp]\n"coms
    "rax" x64n_force_compile_push
    &start_ops_mem->StackHead.data compile_ops
}

:data_x86_64_linux_nasm_generic {
    // -- idx
    0 while dup MAP_SIZE < {
        if dup dup (x64n_is_valid_static_buffer) swap (BUF_MAP map_idx->Buffer.init@ flag) & {
            dup x64n_compile_buf_data
        }
        1+
    } drop
    x64n_compile_inline_bufs
}

:bss_x86_64_linux_nasm_generic {
    // -- idx
    0 while dup MAP_SIZE < {
        if dup dup (x64n_is_valid_static_buffer) swap (BUF_MAP map_idx->Buffer.init@ not) & {
            dup x64n_compile_buf_bss
        }
        1+
    } drop
    "    bsp:"coms x64n_compile_resb ASM_STACK_SIZE com "\n"coms
}

pub :compile_program_x86_64_linux_nasm {
    "BITS 64\n"coms
    "global _start\n"coms
    "section .text\n"coms
    text_x86_64_linux_nasm_generic
    "section .data\n"coms
    data_x86_64_linux_nasm_generic
    "section .bss\n"coms
    bss_x86_64_linux_nasm_generic
}

pub :compile_program_x86_64_linux_fasm {
    "format ELF64\n"coms
    "public _start\n"coms
    "section '.text' executable\n"coms
    text_x86_64_linux_nasm_generic
    "section '.data' writeable\n"coms
    data_x86_64_linux_nasm_generic
    "section '.bss' writeable\n"coms
    bss_x86_64_linux_nasm_generic
}