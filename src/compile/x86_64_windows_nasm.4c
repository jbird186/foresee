#use "x86_64_nasm_common.4c"

// name alloc_size --
:win_call {
    "    sub     rsp, 32\n"coms
    "    call    "coms coms "\n"coms
    "    add     rsp, 32\n"coms
}

// op_ptr -- new_op_ptr
:compile_op {
    if viewok OKind.EXIT == {
        "    ; OP_EXIT\n"coms_dbg
        "rcx" x64n_compile_pop
        "ExitProcess" win_call
    }
    else if viewok OKind.FOPEN == {
        "    ; OP_FOPEN\n"coms_dbg
        "rax" x64n_compile_pop                       // mode (0 = read, 1 = write, 2 = append)
        "rcx" x64n_compile_pop                       // filename pointer
        x64n_flush_push_cache
        "    sub     rsp, 32+24\n"coms
        "    cmp     rax, 0\n"coms
        "    je      .frl_"coms viewod com "\n"coms
        "    cmp     rax, 1\n"coms
        "    je      .fwl_"coms viewod com "\n"coms
        "    cmp     rax, 2\n"coms
        "    je      .fal_"coms viewod com "\n"coms
        "    jmp     .ffl_"coms viewod com "\n"coms
        "    .frl_"coms viewod com ":\n"coms
        "    mov     rdx, 80000000h\n"coms      // dwDesiredAccess
        "    mov     qword [rsp+32], 3\n"coms   // dwCreationDisposition
        "    jmp     .fdl_"coms viewod com "\n"coms
        "    .fwl_"coms viewod com ":\n"coms
        "    mov     rdx, 40000000h\n"coms      // dwDesiredAccess
        "    mov     qword [rsp+32], 2\n"coms   // dwCreationDisposition
        "    jmp     .fdl_"coms viewod com "\n"coms
        "    .fal_"coms viewod com ":\n"coms
        "    mov     rdx, 00000004h\n"coms      // dwDesiredAccess
        "    mov     qword [rsp+32], 4\n"coms   // dwCreationDisposition
        "    jmp     .fdl_"coms viewod com "\n"coms
        "    .fdl_"coms viewod com ":\n"coms
        "    mov     r8, 0\n"coms               // dwShareMode
        "    mov     r9, 0\n"coms               // lpSecurityAttributes
        "    mov     qword [rsp+40], 80h\n"coms // dwFlagsAndAttributes
        "    mov     qword [rsp+48], 0\n"coms   // hTemplateFile
        "    call    CreateFileA\n"coms
        "rax" x64n_force_compile_push                // push FD (or -1 on error)
        x64n_flush_stack_ptr_delta
        "    jmp     .fel_"coms viewod com "\n"coms
        "    .ffl_"coms viewod com ":\n"coms
        "    mov     rax, -1\n"coms
        "rax" x64n_force_compile_push
        x64n_flush_stack_ptr_delta
        "    .fel_"coms viewod com ":\n"coms
        "    add     rsp, 32+24\n"coms
    }
    else if viewok OKind.FREAD == {
        "    ; OP_FREAD\n"coms_dbg
        "rcx" x64n_compile_pop                       // file descriptor
        "r8" x64n_compile_pop                        // length
        "rdx" x64n_compile_pop                       // buffer pointer
        x64n_flush_push_cache
        "    lea     r9, [rel windata]\n"coms   // lpNumberOfBytesRead
        "    sub     rsp, 32+8\n"coms
        "    mov     qword [rsp+32], 0\n"coms   // lpOverlapped
        "    call    ReadFile\n"coms
        "    add     rsp, 32+8\n"coms
        "    cmp     eax, 0\n"coms
        "    jne     .frl_"coms viewod com "\n"coms
        "    mov     rax, -1\n"coms
        "    jmp     .ffl_"coms viewod com "\n"coms
        "    .frl_"coms viewod com ":\n"coms
        "    mov     rax, [rel windata]\n"coms
        "    .ffl_"coms viewod com ":\n"coms
        "rax" x64n_compile_push                      // bytes read or -1
    }
    else if viewok OKind.FWRITE == {
        "    ; OP_FWRITE\n"coms_dbg
        "rcx" x64n_compile_pop                  // file descriptor
        "r8" x64n_compile_pop                   // length
        "rdx" x64n_compile_pop                  // buffer pointer
        x64n_flush_push_cache
        "    lea     r9, [rel windata]\n"coms   // lpNumberOfBytesWritten
        "    sub     rsp, 32+8\n"coms
        "    mov     qword [rsp+32], 0\n"coms   // lpOverlapped
        "    call    WriteFile\n"coms
        "    add     rsp, 32+8\n"coms
        "    cmp     eax, 0\n"coms
        "    jne     .fwl_"coms viewod com "\n"coms
        "    mov     rax, -1\n"coms
        "    jmp     .ffl_"coms viewod com "\n"coms
        "    .fwl_"coms viewod com ":\n"coms
        "    mov     rax, [rel windata]\n"coms
        "    .ffl_"coms viewod com ":\n"coms
        "rax" x64n_compile_push                 // bytes written or -1
    }
    else if viewok OKind.FCLOSE == {
        "    ; OP_FCLOSE\n"coms_dbg
        "rcx" x64n_compile_pop           // file descriptor
        x64n_flush_push_cache
        "CloseHandle" win_call
        "    sub     rax, 1\n"coms
        "rax" x64n_compile_push          // 0 or -1
    }
    else if viewok OKind.GETCWD == {
        "    ; OP_GETCWD\n"coms_dbg
        "rcx" x64n_compile_pop      // length
        "rdx" x64n_compile_pop      // buffer pointer
        x64n_flush_push_cache
        "    mov     r11, rcx\n"coms
        "GetCurrentDirectoryA" win_call
        "    cmp     rax, r11\n"coms
        "    jg      .csl_"coms viewod com "\n"coms
        "    test    rax, rax\n"coms
        "    jz      .czl_"coms viewod com "\n"coms
        "    jmp     .cfl_"coms viewod com "\n"coms
        "    .csl_"coms viewod com ":\n"coms
        "    neg     rax\n"coms     // buffer too small
        "    jmp     .cfl_"coms viewod com "\n"coms
        "    .czl_"coms viewod com ":\n"coms
        "    mov     rax, -1\n"coms // misc error
        "    .cfl_"coms viewod com ":\n"coms
        "rax" x64n_compile_push     // bytes written or error
    }
    // Windows Only
    else if viewok OKind.WIN_GetCommandLineW == {
        "    ; WIN_GetCommandLineW\n"coms_dbg
        x64n_flush_push_cache
        "GetCommandLineW" win_call
        "rax" x64n_compile_push
    }
    else if viewok OKind.WIN_CommandLineToArgvW == {
        "    ; WIN_CommandLineToArgvW\n"coms_dbg
        "rdx" x64n_compile_pop // pNumArgs
        "rcx" x64n_compile_pop // lpCmdLine
        x64n_flush_push_cache
        "CommandLineToArgvW" win_call
        "    test    rax, rax\n"coms
        "    jnz     .cll_"coms viewod com "\n"coms
        "    mov     rax, -1\n"coms
        "    .cll_"coms viewod com ":\n"coms
        "rax" x64n_compile_push
    }
    else if viewok OKind.WIN_WideCharToMultiByte == {
        "    ; WIN_WideCharToMultiByte\n"coms_dbg
        "rax" x64n_compile_pop                  // cbMultiByte
        "rbx" x64n_compile_pop                  // lpMultiByteStr
        "r8" x64n_compile_pop                   // lpWideCharStr
        x64n_flush_push_cache
        "    mov     r9, -1\n"coms              // cchWideChar
        "    mov     rcx, 65001\n"coms          // CodePage
        "    mov     rdx, 0\n"coms              // dwFlags
        "    sub     rsp, 32+32\n"coms
        "    mov     qword [rsp+32], rbx\n"coms
        "    mov     qword [rsp+40], rax\n"coms
        "    mov     qword [rsp+48], 0\n"coms   // lpDefaultChar
        "    mov     qword [rsp+56], 0\n"coms   // lpUsedDefaultChar
        "    call    WideCharToMultiByte\n"coms
        "    add     rsp, 32+32\n"coms
        "    test    rax, rax\n"coms
        "    jnz     .wcl_"coms viewod com "\n"coms
        "    mov     rax, -1\n"coms
        "    .wcl_"coms viewod com ":\n"coms
        "rax" x64n_compile_push
    }
    else if viewok OKind.WIN_LocalAlloc == {
        "    ; WIN_LocalAlloc\n"coms_dbg
        "rdx" x64n_compile_pop      // uBytes
        x64n_flush_push_cache
        "    mov     rcx, 64\n"coms // uFlags
        "LocalAlloc" win_call
        "    test    rax, rax\n"coms
        "    jnz     .lal_"coms viewod com "\n"coms
        "    mov     rax, -1\n"coms
        "    .lal_"coms viewod com ":\n"coms
        "rax" x64n_compile_push
    }
    else if viewok OKind.WIN_LocalFree == {
        "    ; WIN_LocalFree\n"coms_dbg
        "rcx" x64n_compile_pop // hMem
        x64n_flush_push_cache
        "LocalFree" win_call
        "    neg     rax\n"coms
        "rax" x64n_compile_push
    }
    else if viewok OKind.WIN_GetStdHandle == {
        "    ; WIN_GetStdHandle\n"coms_dbg
        "rcx" x64n_compile_pop // nStdHandle
        x64n_flush_push_cache
        "GetStdHandle" win_call
        "rax" x64n_compile_push
    }
    else { x64n_compile_generic_op }
    %Op+
}

x64n_compile_text_fns

pub :compile_program_x86_64_windows_nasm {
    "BITS 64\n"coms

    "extern ExitProcess\n"coms
    "extern CreateFileA\n"coms
    "extern ReadFile\n"coms
    "extern WriteFile\n"coms
    "extern CloseHandle\n"coms
    "extern GetCurrentDirectoryA\n"coms

    "extern GetCommandLineW\n"coms
    "extern CommandLineToArgvW\n"coms
    "extern WideCharToMultiByte\n"coms
    "extern LocalAlloc\n"coms
    "extern LocalFree\n"coms
    "extern GetStdHandle\n"coms

    "global _start\n"coms
    "section .text\n"coms
    compile_functions

    "; start\n"coms_dbg
    "_start:\n"coms
    "    lea     r12, [rel bsp + "coms ASM_STACK_SIZE com "]\n"coms
    &start_ops_mem->StackHead.data compile_ops

    "section .data\n"coms

    // -- idx
    0 while dup MAP_SIZE < {
        if dup dup (x64n_is_valid_static_buffer) swap (BUF_MAP map_idx->Buffer.init@ flag) & {
            dup x64n_compile_buf_data
        }
        1+
    } drop
    x64n_compile_inline_bufs

    "section .bss\n"coms
    // -- idx
    0 while dup MAP_SIZE < {
        if dup dup (x64n_is_valid_static_buffer) swap (BUF_MAP map_idx->Buffer.init@ not) & {
            dup x64n_compile_buf_bss
        }
        1+
    } drop
    "    windata resd 1\n"coms
    "    bsp:"coms x64n_compile_resb ASM_STACK_SIZE com "\n"coms
}