#use "compile/common.4c"
#use "stdstr.4c"
#use "stdchar.4c"
#use "config.4c"
#use "map.4c"
#use "op.4c"

static int stack_ptr_delta
:com_stack_delta {
    if stack_ptr_delta 0 > {
        " + "coms stack_ptr_delta com
    } else if stack_ptr_delta 0 < {
        " - "coms stack_ptr_delta -1* com
    }
}

pub :x64n_flush_stack_ptr_delta {
    if stack_ptr_delta 0 > {
        "    add     r12, "coms stack_ptr_delta com "\n"coms
    } else if stack_ptr_delta 0 < {
        "    sub     r12, "coms stack_ptr_delta -1* com "\n"coms
    }
    0 =stack_ptr_delta
}

// n --
:update_stack_ptr_delta {
    +=stack_ptr_delta
    if optimize_mode not {
        x64n_flush_stack_ptr_delta
    }
}

// item --
pub :x64n_force_compile_push {
    -8 update_stack_ptr_delta
    "    mov     qword [r12"coms com_stack_delta "], "coms coms "\n"coms
}

static char[32] push_cache
pub :x64n_flush_push_cache {
    if &push_cache@ {
        &push_cache x64n_force_compile_push
        NULL &push_cache!
    }
}

// item --
pub :x64n_compile_push {
    if optimize_mode {
        x64n_flush_push_cache
        &push_cache strcpy
        return
    }
    x64n_force_compile_push
}

:compile_stack_shrink {
    if &push_cache@ {
        NULL &push_cache!
        return
    }
    8 update_stack_ptr_delta
}

// item --
pub :x64n_compile_pop {
    if &push_cache@ {
        if dup &push_cache strcmp {
            "    mov     "coms coms ", "coms &push_cache coms "\n"coms
        } else {
            drop
        }
        NULL &push_cache!
        return
    }
    "    mov     "coms coms ", qword [r12"coms com_stack_delta "]\n"coms
    8 update_stack_ptr_delta
}

// b_register instruction name --
:compile_basic_binop {
    "    ; "coms_dbg coms_dbg "\n"coms_dbg
    "rcx" x64n_compile_pop
    "rax" x64n_compile_pop
    "    "coms coms " \trax, "coms coms "\n"coms
    "rax" x64n_compile_push
}

:compile_nasm_rel {
    if "TOOLCHAIN_NASM" has_builtin_flag {
        "rel "coms
    }
}

// op_ptr -- op_ptr
pub :x64n_compile_generic_op {
    switch viewok {
    case OKind.NOOP {}
    case OKind.CALL {
        "    ; OP_CALL\n"coms_dbg
        "rax" x64n_compile_pop
        x64n_flush_stack_ptr_delta
        "    call    rax\n"coms
    }
    case OKind.PUSH_FN {
        "    ; OP_PUSH_FN\n"coms_dbg
        "    lea     rax, [f_"coms viewod com "]\n"coms
        "rax" x64n_compile_push
    }
    case OKind.CALL_FN {
        x64n_flush_push_cache
        x64n_flush_stack_ptr_delta
        "    ; OP_CALL_FN\n"coms_dbg
        "    call    f_"coms viewod com "\n"coms
    }
    case OKind.RET {
        x64n_flush_push_cache
        x64n_flush_stack_ptr_delta
        "    ; OP_RET\n"coms_dbg
        "    leave\n"coms
        "    ret\n"coms
    }
    case OKind.PUSH_INT {
        "    ; OP_PUSH_INT\n"coms_dbg
        if viewod dup (1 31 << 1- >) swap (1 31 << -1* <) | {
            x64n_flush_push_cache
            "    mov     rax, "coms viewod com "\n"coms
            "rax" x64n_compile_push
        } else {
            var char[32] buf_name
            viewod &buf_name itoa
            &buf_name x64n_compile_push
        }
    }
    case OKind.DROP {
        "    ; OP_DROP\n"coms_dbg
        compile_stack_shrink
    }
    case OKind.PICK {
        "    ; OP_PICK\n"coms_dbg
        "rax" x64n_compile_pop
        x64n_flush_stack_ptr_delta
        "    mov     rax, [r12 + rax*8]\n"coms
        "rax" x64n_compile_push
    }
    case OKind.ROLL {
        "    ; OP_ROLL\n"coms_dbg
        "rax" x64n_compile_pop
        x64n_flush_push_cache
        x64n_flush_stack_ptr_delta
        "    mov     rcx, [r12 + rax*8]\n"coms
        "    lea     rbx, [r12 + rax*8]\n"coms
        "    .ral_"coms viewod com_label ":\n"coms
        "    cmp     rbx, r12\n"coms
        "    je      .rbl_"coms viewod com_label "\n"coms
        "    mov     rdx, [rbx - 8]\n"coms
        "    mov     [rbx], rdx\n"coms
        "    sub     rbx, 8\n"coms
        "    jmp     .ral_"coms viewod com_label "\n"coms
        "    .rbl_"coms viewod com_label ":\n"coms
        "    mov     [r12], rcx\n"coms
    }
    case OKind.DUP {
        "    ; OP_DUP\n"coms_dbg
        x64n_flush_push_cache
        x64n_flush_stack_ptr_delta
        "    mov     rax, [r12]\n"coms
        "rax" x64n_compile_push
    }
    case OKind.OVER {
        "    ; OP_OVER\n"coms_dbg
        x64n_flush_push_cache
        x64n_flush_stack_ptr_delta
        "    mov     rax, [r12 + 8]\n"coms
        "rax" x64n_compile_push
    }
    case OKind.SWAP {
        "    ; OP_SWAP\n"coms_dbg
        "rax" x64n_compile_pop
        "rbx" x64n_compile_pop
        "rax" x64n_compile_push
        "rbx" x64n_compile_push
    }
    case OKind.ROT {
        "    ; OP_ROT\n"coms_dbg
        "rax" x64n_compile_pop
        "rbx" x64n_compile_pop
        "rcx" x64n_compile_pop
        "rbx" x64n_compile_push
        "rax" x64n_compile_push
        "rcx" x64n_compile_push
    }
    case OKind.NIP {
        "    ; OP_NIP\n"coms_dbg
        "rax" x64n_compile_pop
        compile_stack_shrink
        "rax" x64n_compile_push
    }
    case OKind.DEPTH {
        x64n_flush_push_cache
        x64n_flush_stack_ptr_delta
        "    ; OP_DEPTH\n"coms_dbg
        "    mov     rax, bsp + "coms ASM_STACK_SIZE com "\n"coms
        "    sub     rax, r12\n"coms
        "    shr     rax, 3\n"coms
        "rax" x64n_compile_push
    }
    case OKind.PUSH_BUF {
        x64n_flush_push_cache
        "    ; OP_PUSH_BUF\n"coms_dbg
        "    lea     rax, ["coms compile_nasm_rel "b_"coms viewod com "]\n"coms
        "rax" x64n_compile_push
    }
    case OKind.STORE {
        "    ; OP_STORE\n"coms_dbg
        "rax" x64n_compile_pop
        "rcx" x64n_compile_pop
        "    mov     [rax], rcx\n"coms
    }
    case OKind.FETCH {
        "    ; OP_FETCH\n"coms_dbg
        "rax" x64n_compile_pop
        "    mov     rax, qword [rax]\n"coms
        "rax" x64n_compile_push
    }
    case OKind.MEMCPY {
        "    ; OP_MEMCPY\n"coms_dbg
        "rcx" x64n_compile_pop
        "rdi" x64n_compile_pop
        "rsi" x64n_compile_pop
        "    cld\n"coms
        "    rep     movsb\n"coms
    }
    case OKind.PUSH_VAR {
        x64n_flush_push_cache
        "    ; OP_PUSH_VAR\n"coms_dbg
        "    lea     rax, [rbp - "coms viewod com "]\n"coms
        "rax" x64n_compile_push
    }
    case OKind.ALLOC {
        "    ; OP_ALLOC\n"coms_dbg
        "    sub     rsp, "coms viewod com "\n"coms
    }
    case OKind.ADD {
        "rcx" "add" "OP_ADD" compile_basic_binop
    }
    case OKind.SUB {
        "rcx" "sub" "OP_SUB" compile_basic_binop
    }
    case OKind.MUL {
        "rcx" "imul" "OP_MUL" compile_basic_binop
    }
    case OKind.AND {
        "rcx" "and" "OP_AND" compile_basic_binop
    }
    case OKind.OR {
        "rcx" "or" "OP_OR" compile_basic_binop
    }
    case OKind.XOR {
        "rcx" "xor" "OP_XOR" compile_basic_binop
    }
    case OKind.SHL {
        "cl" "shl" "OP_SHL" compile_basic_binop
    }
    case OKind.SHR {
        "cl" "shr" "OP_SHR" compile_basic_binop
    }
    case OKind.SAR {
        "cl" "sar" "OP_SAR" compile_basic_binop
    }
    case OKind.NOT {
        "    ; OP_NOT\n"coms_dbg
        "rax" x64n_compile_pop
        "    not     rax\n"coms
        "rax" x64n_compile_push
    }
    case OKind.EQ {
        "    ; OP_EQ\n"coms_dbg
        "rax" x64n_compile_pop
        "rbx" x64n_compile_pop
        "    cmp     rbx, rax\n"coms
        "    sete    al\n"coms
        "    movzx   rax, al\n"coms
        "rax" x64n_compile_push
    }
    case OKind.GT {
        "    ; OP_GT\n"coms_dbg
        "rax" x64n_compile_pop
        "rbx" x64n_compile_pop
        "    cmp     rbx, rax\n"coms
        "    setg    al\n"coms
        "    movzx   rax, al\n"coms
        "rax" x64n_compile_push
    }
    case OKind.LT {
        "    ; OP_LT\n"coms_dbg
        "rax" x64n_compile_pop
        "rbx" x64n_compile_pop
        "    cmp     rbx, rax\n"coms
        "    setl    al\n"coms
        "    movzx   rax, al\n"coms
        "rax" x64n_compile_push
    }
    case OKind.DIVMOD {
        "    ; OP_DIVMOD\n"coms_dbg
        "rbx" x64n_compile_pop
        "rax" x64n_compile_pop
        "    cqo\n"coms
        "    idiv    rbx\n"coms
        "rax" x64n_compile_push
        "rdx" x64n_compile_push
    }
    case OKind.LABEL {
        x64n_flush_push_cache
        x64n_flush_stack_ptr_delta
        ".l_"coms viewod com_label ":\n"coms
    }
    case OKind.JMP {
        x64n_flush_push_cache
        x64n_flush_stack_ptr_delta
        "    ; OP_JMP\n"coms_dbg
        "    jmp     .l_"coms viewod com_label "\n"coms
    }
    case OKind.JZ {
        "    ; OP_JZ\n"coms_dbg
        "rax" x64n_compile_pop
        x64n_flush_push_cache
        x64n_flush_stack_ptr_delta
        "    test    rax, rax\n"coms
        "    jz      .l_"coms viewod com_label "\n"coms
    }
    case OKind.PRE_CMP {
        "    ; OP_PRE_CMP\n"coms_dbg
        "rax" x64n_compile_pop
        x64n_flush_stack_ptr_delta
        "    mov     [rsp-8], rax\n"coms
    }
    case OKind.CMP {
        "    ; OP_CMP\n"coms_dbg
        "    cmp     qword [rsp-8], "coms viewod com "\n"coms
    }
    case OKind.JCMP {
        "    ; OP_JCMP\n"coms_dbg
        x64n_flush_push_cache
        x64n_flush_stack_ptr_delta
        "    jl      .l_"coms viewod com_label "\n"coms
        "    jg      .l_"coms viewod 1+ com_label "\n"coms
    }
    case OKind.JCMPNE {
        "    ; OP_JCMPNE\n"coms_dbg
        x64n_flush_push_cache
        x64n_flush_stack_ptr_delta
        "    jne     .l_"coms viewod com_label "\n"coms
    }
    default {
        "ERROR: Invalid opcode (#"puts viewok put ")\n"puts
        1 exit
    }
    }
}

#pub macro x64n_compile_text_fns {
    // op_ptr --
    :compile_ops {
        while viewok { compile_op }
        drop
    }

    // idx map_slot_ptr -- idx
    :compile_function {
        var &Function f: {}
        if f->def not {
            f->file puts ": ERROR: Function '"puts f->key.name puts "' was never defined\n"puts
            1 exit
        }
        if f->is_used not {
            if f->key.scope {
                f->file puts ": WARNING: Private function '" puts f->key.name puts "' is never used\n" puts
            }
            if optimize_mode { return }
        }
        dup =FN_IDX
        if debug_mode {
            "; "coms f->key.name coms "\n"coms
        }
        "f_"coms dup com ":\n"coms
        "    push    rbp\n"coms
        "    mov     rbp, rsp\n"coms
        f->def compile_ops
    }

    :compile_functions {
        // -- idx
        0 while dup MAP_SIZE < {
            // -- idx slot_ptr
            dup FN_MAP map_idx
            if dup slot_is_used { compile_function }
            else { drop }
            1+
        } drop
    }
}

// char -- bool
:should_print_char {
    dup isprint
    swap (dup ('\\' !=) swap ('"' !=) &) &
    USE_ASM_STRINGS &
}

// init --
:compile_buf_str {
    var char is_quote: {false}
    while dup@c {
        if dup@c should_print_char {
            if is_quote not {
                "\""coms
                true =is_quote
            }
            dup@c comc
        } else {
            if is_quote {
                "\","coms
                false =is_quote
            }
            dup@c com
            ","coms
        }
        1+
    } drop

    if is_quote {
        "\","coms
    }
    "0\n" coms
}

pub :rodata_x86_64_nasm_generic {
    // -- idx
    0 while dup MAP_SIZE < {
        if dup INLINE_STR_MAP map_idx slot_is_used {
            "    b_"coms dup MAP_SIZE+ com " db "coms
            dup INLINE_STR_MAP map_idx as InlineStr.value@ compile_buf_str
        }
        1+
    } drop
}

// idx --
pub :x64n_compile_buf_data {
    var int buf_size: {dup BUF_MAP map_idx as Buffer.size@}

    if debug_mode {
        "    ; "coms dup BUF_MAP map_idx as Buffer.key.name@ coms "\n"coms
    }
    "    b_"coms dup com

    if dup BUF_MAP map_idx as Buffer.init_int@c {
        if buf_size 1 == {
            " db "coms BUF_MAP map_idx as Buffer.init@ com "\n"coms
        } else if buf_size 8 == {
            " dq "coms BUF_MAP map_idx as Buffer.init@ com "\n"coms
        }
    } else {
        " db "coms
        dup BUF_MAP map_idx as Buffer.init@ compile_buf_str
        if (dup BUF_MAP map_idx as Buffer.init@ strlen 1+) (buf_size) < {
            "        times "coms buf_size com " - ($ - b_"coms dup com ") db 0\n"coms
        }
        drop
    }
}

pub :x64n_compile_resb {
    if "TOOLCHAIN_NASM" has_builtin_flag {
        " resb "
    } else {
        " rb "
    }
    coms
}

// idx --
pub :x64n_compile_buf_bss {
    var int idx: {}
    var &Buffer buf: {idx BUF_MAP map_idx}
    "    b_"coms idx com x64n_compile_resb buf->size com
    if debug_mode {
        " ; "coms buf->key.name coms
    }
    "\n"coms
}

// idx -- bool
pub :x64n_is_valid_static_buffer {
    BUF_MAP map_idx
    dup as Buffer.key.name@ flag
    swap as Buffer.is_static@c
    &
}

pub :data_x86_64_nasm_generic {
    for (var int i: 0, i MAP_SIZE <, 1 +=i) {
        if (i x64n_is_valid_static_buffer) (i BUF_MAP map_idx as Buffer.init@ flag) & {
            i x64n_compile_buf_data
        }
    }
}

pub :bss_x86_64_nasm_generic {
    for (var int i: 0, i MAP_SIZE <, 1 +=i) {
        if (i x64n_is_valid_static_buffer) (i BUF_MAP map_idx as Buffer.init@ not) & {
            i x64n_compile_buf_bss
        }
    }
}